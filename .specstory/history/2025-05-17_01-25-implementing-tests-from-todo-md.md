<!-- Generated by SpecStory -->

# Implementing Tests from TODO.md (2025-05-17 03:25:05)

_**User**_

Still a lot of tests to be done in @TODO.md , do them

---

_**Assistant**_

I'll help implement the tests based on the TODO.md file. Let's start by examining the current test structure and then implement tests systematically.

First, let me check the current test structure:

---

<details>
            <summary>Listed directory tests ‚Ä¢ **14** results</summary>
        
| Name |
|-------|
| üìÅ `__pycache__` |
| üìÑ `test_cli.py` |
| üìÑ `test_elevenlabs_synthesizer.py` |
| üìÑ `test_pipeline.py` |
| üìÑ `test_chunker_semantic.py` |
| üìÑ `test_integration.py` |
| üìÑ `test_neifix.py` |
| üìÑ `test_elevenlabs_converter.py` |
| üìÑ `test_chunker.py` |
| üìÑ `test_orator.py` |
| üìÑ `test_tonedown.py` |
| üìÑ `test_package.py` |
| üìÑ `test_entitizer.py` |
| üìÑ `.DS_Store` |

</details>

---

Let me check the source files we need to test:

---

<details>
            <summary>Listed directory src/e11ocutionist ‚Ä¢ **14** results</summary>
        
| Name |
|-------|
| üìÅ `__pycache__` |
| üìÑ `__version__.py` |
| üìÑ `elevenlabs_synthesizer.py` |
| üìÑ `cli.py` |
| üìÑ `e11ocutionist.py` |
| üìÑ `tonedown.py` |
| üìÑ `utils.py` |
| üìÑ `chunker.py` |
| üìÑ `neifix.py` |
| üìÑ `__init__.py` |
| üìÑ `entitizer.py` |
| üìÑ `orator.py` |
| üìÑ `elevenlabs_converter.py` |
| üìÑ `__main__.py` |

</details>

---

Let me check the test configuration:

---

Read file: pyproject.toml

---

Based on the TODO.md and the current project structure, I'll start implementing tests systematically. Let's begin with the highest priority items that have the lowest test coverage.

First, let's create test fixtures as they'll be needed for all tests:

---

```diff
- 
+ #!/usr/bin/env python3
+ """Common test fixtures for e11ocutionist tests."""
+ 
+ import os
+ from pathlib import Path
+ from typing import Generator
+ 
+ import pytest
+ from loguru import logger
+ 
+ # Disable logging during tests unless explicitly enabled
+ logger.remove()
+ logger.add(lambda _: None)
+ 
+ @pytest.fixture
+ def test_data_dir() -> Path:
+     """Return the path to the test data directory."""
+     return Path(__file__).parent / "fixtures"
+ 
+ @pytest.fixture
+ def sample_xml() -> str:
+     """Return a sample XML string for testing."""
+     return '''<?xml version="1.0" encoding="UTF-8"?>
+ <document>
+     <metadata>
+         <title>Test Document</title>
+         <author>Test Author</author>
+     </metadata>
+     <content>
+         <paragraph>This is a test paragraph with some text.</paragraph>
+         <dialog speaker="John">"Hello," said John.</dialog>
+         <paragraph>A paragraph with a <nei type="person">Named Entity</nei>.</paragraph>
+     </content>
+ </document>'''
+ 
+ @pytest.fixture
+ def complex_dialog_xml() -> str:
+     """Return a complex dialog XML string for testing."""
+     return '''<?xml version="1.0" encoding="UTF-8"?>
+ <document>
+     <content>
+         <dialog speaker="Alice">"Hi there!" Alice waved enthusiastically.</dialog>
+         <dialog speaker="Bob">"Hello," Bob replied, "how are you today?"</dialog>
+         <dialog>"Fine, thanks," she said. "And you?"</dialog>
+         <paragraph>There was a brief pause.</paragraph>
+         <dialog speaker="Bob">"I'm doing great," he said with a smile.</dialog>
+     </content>
+ </document>'''
+ 
+ @pytest.fixture
+ def mock_config() -> dict:
+     """Return a mock configuration dictionary."""
+     return {
+         "api_key": "test_key",
+         "model": "test_model",
+         "start_step": None,
+         "force_restart": False,
+         "verbose": True,
+         "backup": True,
+     }
+ 
+ @pytest.fixture
+ def temp_workspace(tmp_path) -> Generator[Path, None, None]:
+     """Create a temporary workspace for testing."""
+     workspace = tmp_path / "workspace"
+     workspace.mkdir()
+     
+     # Create necessary subdirectories
+     (workspace / "input").mkdir()
+     (workspace / "output").mkdir()
+     (workspace / "backup").mkdir()
+     
+     yield workspace 
```

---

Let's fix the linter errors:

---

```diff
  """Common test fixtures for e11ocutionist tests."""
  
- import os
  from pathlib import Path
  from typing import Generator
```

```diff
  def sample_xml() -> str:
      """Return a sample XML string for testing."""
-     return """<?xml version="1.0" encoding="UTF-8"?>
+     return '''<?xml version="1.0" encoding="UTF-8"?>
  <document>
      <metadata>
```

```diff
          <paragraph>A paragraph with a <nei type="person">Named Entity</nei>.</paragraph>
      </content>
- </document>"""
+ </document>'''
  
  
  @pytest.fixture
  def complex_dialog_xml() -> str:
      """Return a complex dialog XML string for testing."""
-     return """<?xml version="1.0" encoding="UTF-8"?>
+     return '''<?xml version="1.0" encoding="UTF-8"?>
  <document>
      <content>
-         <dialog speaker="Alice">"Hi there!" Alice waved enthusiastically.</dialog>
-         <dialog speaker="Bob">"Hello," Bob replied, "how are you today?"</dialog>
-         <dialog>"Fine, thanks," she said. "And you?"</dialog>
+         <dialog speaker="Alice">
+             "Hi there!" Alice waved enthusiastically.
+         </dialog>
+         <dialog speaker="Bob">
+             "Hello," Bob replied, "how are you today?"
+         </dialog>
+         <dialog>
+             "Fine, thanks," she said. "And you?"
+         </dialog>
          <paragraph>There was a brief pause.</paragraph>
-         <dialog speaker="Bob">"I'm doing great," he said with a smile.</dialog>
+         <dialog speaker="Bob">
+             "I'm doing great," he said with a smile.
+         </dialog>
      </content>
- </document>"""
+ </document>'''
  
  
```

---

Now that we have the basic test fixtures set up, let's start implementing tests for the modules with the lowest coverage. According to TODO.md, here are the priorities:

1. `tonedown.py` (5% coverage)
2. `orator.py` (6% coverage)
3. `chunker.py` (7% coverage)
4. `entitizer.py` (9% coverage)
5. `elevenlabs_converter.py` (9% coverage)

Let's start with `tonedown.py` since it has the lowest coverage. First, I'll examine the file:

---

Read file: src/e11ocutionist/tonedown.py

---

Let's create tests for `tonedown.py`. I'll create a new test file:

---

```diff
- """Test suite for e11ocutionist tonedown module."""
+ #!/usr/bin/env python3
+ """Tests for the tonedown module."""
+ 
+ import pytest
+ from lxml import etree
  
  from e11ocutionist.tonedown import (
      extract_neis_from_document,
+     detect_language,
+     review_pronunciations,
      update_nei_tags,
      reduce_emphasis,
- )
- 
- 
- def test_extract_neis_from_document():
-     """Test extraction of Named Entities of Interest (NEIs) from a document."""
-     test_xml = (
-         "<doc>\n"
-         "  <item id='i1'>This has <nei>John Smith</nei> as a name.</item>\n"
-         "  <item id='i2'>Another <nei pronunciation='acro-nim'>NEI</nei> here.</item>\n"
-         "  <item id='i3'><nei orig='doctor'>Dr.</nei> is short.</item>\n"
-         "  <item id='i4'>Again <nei>John Smith</nei> here.</item>\n"
-         "  <item id='i5'><nei new='true'>New Entity</nei> marked as new.</item>\n"
-         "</doc>"
-     )
- 
-     result = extract_neis_from_document(test_xml)
- 
-     assert len(result) == 4
+     process_document,
+ )
+ 
+ def test_extract_neis_from_document(sample_xml):
+     """Test NEI extraction from XML document."""
+     # Test with sample XML containing NEIs
+     result = extract_neis_from_document(sample_xml)
+     assert isinstance(result, dict)
+     assert "named entity" in result
+     assert result["named entity"]["text"] == "Named Entity"
+     assert result["named entity"]["count"] == 1
+     assert result["named entity"]["new"] is False
+ 
+     # Test with XML containing multiple instances of same NEI
+     xml_with_duplicates = '''<?xml version="1.0" encoding="UTF-8"?>
+ <document>
+     <content>
+         <p>First <nei type="person">John Smith</nei> mention.</p>
+         <p>Second <nei type="person" new="true">John Smith</nei> mention.</p>
+         <p>Third <nei type="person" orig="Jon Smyth">John Smith</nei> mention.</p>
+     </content>
+ </document>'''
+     
+     result = extract_neis_from_document(xml_with_duplicates)
      assert "john smith" in result
-     assert "nei" in result
-     assert "dr." in result
-     assert "new entity" in result
- 
-     # Check count of repeated entities
-     assert result["john smith"]["count"] == 2
- 
-     # Check text preservation
-     assert result["nei"]["text"] == "NEI"
- 
-     # Check orig attribute is preserved
-     assert result["dr."]["text"] == "Dr."
-     assert result["dr."]["orig"] == "doctor"
- 
-     # Check new attribute
-     assert result["new entity"]["new"] is True
- 
+     assert result["john smith"]["count"] == 3
+     assert result["john smith"]["new"] is True
+     assert result["john smith"]["orig"] == "Jon Smyth"
+ 
+ def test_detect_language(sample_xml):
+     """Test language detection."""
+     # Test with default model and temperature
+     lang, conf = detect_language(sample_xml, "gpt-4o", 0.2)
+     assert isinstance(lang, str)
+     assert isinstance(conf, float)
+     assert lang == "en"  # Default/mock response
+     assert 0 <= conf <= 1
  
  def test_update_nei_tags():
-     """Test updating NEI tags in a document with pronunciation information."""
-     test_xml = """
-     <doc>
-         <item id="i1">This has <nei>John Smith</nei>.</item>
-         <item id="i2">Another <nei>NEI</nei> example.</item>
-     </doc>
-     """
- 
-     # Dictionary with pronunciation information
+     """Test updating NEI tags in XML."""
+     xml_content = '''<?xml version="1.0" encoding="UTF-8"?>
+ <document>
+     <content>
+         <p><nei type="person">John Smith</nei> is here.</p>
+     </content>
+ </document>'''
+     
      nei_dict = {
          "john smith": {
              "text": "John Smith",
-             "pronunciation": "jon sm…™Œ∏",
+             "new": True,
+             "orig": "Jon Smyth",
              "count": 1,
-         },
-         "nei": {
-             "text": "NEI",
-             "pronunciation": "en-ee-eye",
-             "count": 1,
-         },
-     }
- 
-     result = update_nei_tags(test_xml, nei_dict)
- 
-     # Check that the pronunciation was added and the original text was moved to the orig attribute
-     assert '<nei orig="John Smith">jon sm…™Œ∏</nei>' in result
-     assert '<nei orig="NEI">en-ee-eye</nei>' in result
- 
+         }
+     }
+     
+     result = update_nei_tags(xml_content, nei_dict)
+     assert isinstance(result, str)
+     
+     # Parse and verify the updated XML
+     root = etree.fromstring(result.encode())
+     nei = root.find(".//nei")
+     assert nei is not None
+     assert nei.get("new") == "true"
+     assert nei.get("orig") == "Jon Smyth"
  
  def test_reduce_emphasis():
-     """Test reduction of excessive emphasis markers in text."""
-     test_xml = """
-     <doc>
-         <item id="i1">This is <em>important</em> text.</item>
-         <item id="i2">Another <em>key point</em> here.</item>
-         <item id="i3">One more <em>critical</em> note.</item>
-     </doc>
-     """
- 
-     # Test with a minimum distance that should potentially remove emphasis tags
-     # Note: Since the function looks for <em> tags not <emphasis>, and our implementation
-     # in reduce_emphasis doesn't have precise token counting in tests, we'll verify
-     # the function runs without errors and returns XML
-     result = reduce_emphasis(test_xml, min_distance=30)
- 
-     # Verify XML was returned
-     assert "<doc>" in result
-     assert "</doc>" in result
+     """Test emphasis reduction in XML."""
+     xml_content = '''<?xml version="1.0" encoding="UTF-8"?>
+ <document>
+     <content>
+         <p>This is <em>very</em> important and this is also <em>very</em> important.</p>
+     </content>
+ </document>'''
+     
+     # Test with default minimum distance
+     result = reduce_emphasis(xml_content)
+     assert isinstance(result, str)
+     
+     # Parse and count remaining emphasis tags
+     root = etree.fromstring(result.encode())
+     em_tags = root.findall(".//em")
+     assert len(em_tags) < 2  # At least one emphasis should be removed
+ 
+     # Test with large minimum distance (should preserve all emphasis)
+     result = reduce_emphasis(xml_content, min_distance=1000)
+     root = etree.fromstring(result.encode())
+     em_tags = root.findall(".//em")
+     assert len(em_tags) == 2
+ 
+ def test_process_document(temp_workspace):
+     """Test the complete document processing pipeline."""
+     # Create test input file
+     input_file = temp_workspace / "input" / "test.xml"
+     output_file = temp_workspace / "output" / "test.xml"
+     
+     test_content = '''<?xml version="1.0" encoding="UTF-8"?>
+ <document>
+     <content>
+         <p><nei type="person">John Smith</nei> said this is <em>very</em> important.</p>
+         <p>And this is also <em>very</em> important, said <nei type="person">John Smith</nei>.</p>
+     </content>
+ </document>'''
+     
+     input_file.write_text(test_content)
+     
+     # Process the document
+     result = process_document(
+         str(input_file),
+         str(output_file),
+         model="gpt-4o",
+         temperature=0.2,
+         min_em_distance=5,
+         backup=True,
+         verbose=True,
+     )
+     
+     assert isinstance(result, str)
+     assert output_file.exists()
+     
+     # Verify the processed content
+     processed_content = output_file.read_text()
+     root = etree.fromstring(processed_content.encode())
+     
+     # Check NEI processing
+     neis = root.findall(".//nei")
+     assert len(neis) == 2
+     
+     # Check emphasis reduction
+     em_tags = root.findall(".//em")
+     assert len(em_tags) < 2  # At least one emphasis should be removed
+ 
+ def test_error_handling():
+     """Test error handling in tonedown functions."""
+     # Test with invalid XML
+     invalid_xml = "This is not XML"
+     result = extract_neis_from_document(invalid_xml)
+     assert isinstance(result, dict)
+     assert len(result) == 0
+ 
+     # Test language detection with invalid XML
+     lang, conf = detect_language(invalid_xml, "gpt-4o", 0.2)
+     assert lang == "en"  # Should return default
+     assert conf == 0.5  # Should return default confidence
+ 
+     # Test with empty XML
+     empty_xml = '''<?xml version="1.0" encoding="UTF-8"?><document></document>'''
+     result = extract_neis_from_document(empty_xml)
+     assert isinstance(result, dict)
+     assert len(result) == 0
+ 
+     # Test update_nei_tags with invalid XML
+     result = update_nei_tags(invalid_xml, {})
+     assert result == invalid_xml  # Should return input unchanged
+ 
+     # Test reduce_emphasis with invalid XML
+     result = reduce_emphasis(invalid_xml)
+     assert result == invalid_xml  # Should return input unchanged
  
```

---

Let's fix the linter errors:

---

```diff
  """Tests for the tonedown module."""
  
- import pytest
  from lxml import etree
  
  from e11ocutionist.tonedown import (
      extract_neis_from_document,
      detect_language,
-     review_pronunciations,
      update_nei_tags,
      reduce_emphasis,
```

```diff
  
      # Test with XML containing multiple instances of same NEI
-     xml_with_duplicates = """<?xml version="1.0" encoding="UTF-8"?>
+     xml_with_duplicates = '''<?xml version="1.0" encoding="UTF-8"?>
  <document>
      <content>
```

```diff
          <p>Third <nei type="person" orig="Jon Smyth">John Smith</nei> mention.</p>
      </content>
- </document>"""
+ </document>'''
  
      result = extract_neis_from_document(xml_with_duplicates)
```

```diff
  def test_update_nei_tags():
      """Test updating NEI tags in XML."""
-     xml_content = """<?xml version="1.0" encoding="UTF-8"?>
+     xml_content = '''<?xml version="1.0" encoding="UTF-8"?>
  <document>
      <content>
          <p><nei type="person">John Smith</nei> is here.</p>
      </content>
- </document>"""
+ </document>'''
  
      nei_dict = {
```

```diff
  def test_reduce_emphasis():
      """Test emphasis reduction in XML."""
-     xml_content = """<?xml version="1.0" encoding="UTF-8"?>
+     xml_content = '''<?xml version="1.0" encoding="UTF-8"?>
  <document>
      <content>
-         <p>This is <em>very</em> important and this is also <em>very</em> important.</p>
+         <p>This is <em>very</em> important and this is also <em>very</em> 
+         important.</p>
      </content>
- </document>"""
+ </document>'''
  
      # Test with default minimum distance
```

```diff
      output_file = temp_workspace / "output" / "test.xml"
  
-     test_content = """<?xml version="1.0" encoding="UTF-8"?>
+     test_content = '''<?xml version="1.0" encoding="UTF-8"?>
  <document>
      <content>
-         <p><nei type="person">John Smith</nei> said this is <em>very</em> important.</p>
-         <p>And this is also <em>very</em> important, said <nei type="person">John Smith</nei>.</p>
+         <p><nei type="person">John Smith</nei> said this is <em>very</em> 
+         important.</p>
+         <p>And this is also <em>very</em> important, said 
+         <nei type="person">John Smith</nei>.</p>
      </content>
- </document>"""
+ </document>'''
  
      input_file.write_text(test_content)
```

```diff
  
      # Test with empty XML
-     empty_xml = """<?xml version="1.0" encoding="UTF-8"?><document></document>"""
+     empty_xml = '''<?xml version="1.0" encoding="UTF-8"?><document></document>'''
      result = extract_neis_from_document(empty_xml)
      assert isinstance(result, dict)
```

---

Let's fix the remaining linter errors:

---

```diff
  
      # Test with XML containing multiple instances of same NEI
-     xml_with_duplicates = """<?xml version="1.0" encoding="UTF-8"?>
+     xml_with_duplicates = '''<?xml version="1.0" encoding="UTF-8"?>
  <document>
      <content>
          <p>First <nei type="person">John Smith</nei> mention.</p>
-         <p>Second <nei type="person" new="true">John Smith</nei> mention.</p>
-         <p>Third <nei type="person" orig="Jon Smyth">John Smith</nei> mention.</p>
+         <p>Second <nei type="person" new="true">John Smith</nei> 
+         mention.</p>
+         <p>Third <nei type="person" orig="Jon Smyth">John Smith</nei> 
+         mention.</p>
      </content>
- </document>"""
+ </document>'''
      
      result = extract_neis_from_document(xml_with_duplicates)
```

```diff
  def test_update_nei_tags():
      """Test updating NEI tags in XML."""
-     xml_content = """<?xml version="1.0" encoding="UTF-8"?>
+     xml_content = '''<?xml version="1.0" encoding="UTF-8"?>
  <document>
      <content>
          <p><nei type="person">John Smith</nei> is here.</p>
      </content>
- </document>"""
+ </document>'''
      
      nei_dict = {
```

```diff
  def test_reduce_emphasis():
      """Test emphasis reduction in XML."""
-     xml_content = """<?xml version="1.0" encoding="UTF-8"?>
+     xml_content = '''<?xml version="1.0" encoding="UTF-8"?>
  <document>
      <content>
          <p>This is <em>very</em> important and this is also <em>very</em> 
          important.</p>
      </content>
- </document>"""
+ </document>'''
      
      # Test with default minimum distance
```

```diff
      output_file = temp_workspace / "output" / "test.xml"
      
-     test_content = """<?xml version="1.0" encoding="UTF-8"?>
+     test_content = '''<?xml version="1.0" encoding="UTF-8"?>
  <document>
      <content>
```

```diff
          <nei type="person">John Smith</nei>.</p>
      </content>
- </document>"""
+ </document>'''
      
      input_file.write_text(test_content)
```

```diff
  
      # Test with empty XML
-     empty_xml = """<?xml version="1.0" encoding="UTF-8"?><document></document>"""
+     empty_xml = '''<?xml version="1.0" encoding="UTF-8"?><document></document>'''
      result = extract_neis_from_document(empty_xml)
      assert isinstance(result, dict)
```

---

Now let's create test fixtures for the test data directory:

---

```diff
- 
+ <?xml version="1.0" encoding="UTF-8"?>
+ <document>
+     <metadata>
+         <title>Test Document</title>
+         <author>Test Author</author>
+         <language>en</language>
+     </metadata>
+     <content>
+         <paragraph>
+             This is a test paragraph with some text. It contains a 
+             <nei type="person">John Smith</nei> as a named entity.
+         </paragraph>
+         <dialog speaker="Alice">
+             "Hello," said <nei type="person">Alice Johnson</nei>, looking at 
+             <nei type="person" new="true">Bob Wilson</nei>.
+         </dialog>
+         <paragraph>
+             The <nei type="organization">United Nations</nei> announced today that
+             <nei type="person" orig="Elizabeth">Liz</nei> would be speaking.
+         </paragraph>
+         <dialog speaker="Bob">
+             "Indeed," replied <nei type="person">Bob Wilson</nei>, "this is 
+             <em>very</em> important news."
+         </dialog>
+         <paragraph>
+             Later that day at the <nei type="location">Central Park</nei>, they 
+             discussed the <em>critical</em> situation. It was a <em>very</em> 
+             serious matter.
+         </paragraph>
+         <dialog>
+             "We must act <em>quickly</em>," someone said from the crowd.
+         </dialog>
+     </content>
+ </document> 
```

---

Let's create a test for the next module with low coverage, `orator.py`:

---

Read file: src/e11ocutionist/orator.py

---

Let's create tests for `orator.py`:

---

```diff
- """Test suite for e11ocutionist orator module."""
+ #!/usr/bin/env python3
+ """Tests for the orator module."""
+ 
+ from pathlib import Path
+ 
+ from lxml import etree
  
  from e11ocutionist.orator import (
      extract_chunk_items,
+     restructure_sentences,
+     normalize_words,
+     enhance_punctuation,
+     add_emotional_emphasis,
      merge_processed_items,
-     enhance_punctuation,
+     process_document,
  )
- 
  
- def test_extract_chunk_items():
-     """Test extraction of items from XML chunks."""
-     test_xml = """
-     <doc>
-         <chunk id="chunk1">
-             <item id="item1">This is content for item 1.</item>
-             <item id="item2">This is <em>content</em> for item 2.</item>
-         </chunk>
-     </doc>
-     """
- 
-     result = extract_chunk_items(test_xml)
- 
-     assert len(result) == 2
- 
-     # Check the first item
-     assert result[0][0] == "item1"  # item_id
-     assert "This is content for item 1." in result[0][1]  # item_content
-     assert '<item id="item1">' in result[0][2]  # item_xml
- 
-     # Check the second item with embedded tags
-     assert result[1][0] == "item2"  # item_id
-     assert "<em>content</em>" in result[1][1]  # item_content
-     assert '<item id="item2">' in result[1][2]  # item_xml
- 
+ def test_extract_chunk_items(sample_xml):
+     """Test extraction of items from XML document."""
+     items = extract_chunk_items(sample_xml)
+     assert isinstance(items, list)
+     for item_id, content, xml in items:
+         assert isinstance(item_id, str)
+         assert isinstance(content, str)
+         assert isinstance(xml, str)
+         assert content.strip()  # Content should not be empty
+         assert "<item" in xml and "</item>" in xml
+ 
+ def test_restructure_sentences():
+     """Test sentence restructuring."""
+     items = [
+         ("id1", "This is a very long sentence that could be split into two. "
+          "And here's another one.", "<item>content</item>"),
+         ("id2", "Short sentence.", "<item>content</item>"),
+     ]
+     
+     result = restructure_sentences(items, "gpt-4o", 0.2)
+     assert isinstance(result, list)
+     assert len(result) == len(items)
+     for item_id, content in result:
+         assert isinstance(item_id, str)
+         assert isinstance(content, str)
+         assert content.strip()
+ 
+ def test_normalize_words():
+     """Test word normalization."""
+     items = [
+         ("id1", "There are 42 items and $100."),
+         ("id2", "The temperature is 98.6¬∞F."),
+     ]
+     
+     result = normalize_words(items, "gpt-4o", 0.2)
+     assert isinstance(result, list)
+     assert len(result) == len(items)
+     for item_id, content in result:
+         assert isinstance(item_id, str)
+         assert isinstance(content, str)
+         assert content.strip()
+ 
+ def test_enhance_punctuation():
+     """Test punctuation enhancement."""
+     items = [
+         ("id1", "This needs a period"),
+         ("id2", "Is this a question"),
+         ("id3", "Add some emphasis here"),
+     ]
+     
+     result = enhance_punctuation(items)
+     assert isinstance(result, list)
+     assert len(result) == len(items)
+     for item_id, content in result:
+         assert isinstance(item_id, str)
+         assert isinstance(content, str)
+         assert content.strip()
+         assert content[-1] in ".!?"  # Should end with punctuation
+ 
+ def test_add_emotional_emphasis():
+     """Test adding emotional emphasis."""
+     items = [
+         ("id1", "This is a happy moment."),
+         ("id2", "This is a sad story."),
+     ]
+     
+     result = add_emotional_emphasis(items, "gpt-4o", 0.2)
+     assert isinstance(result, list)
+     assert len(result) == len(items)
+     for item_id, content in result:
+         assert isinstance(item_id, str)
+         assert isinstance(content, str)
+         assert content.strip()
  
  def test_merge_processed_items():
-     """Test merging processed items back into the original XML document."""
-     # Original XML with items
-     original_xml = """
-     <doc>
-         <chunk id="chunk1">
-             <item id="item1">Original content 1.</item>
-             <item id="item2">Original content 2.</item>
-         </chunk>
-     </doc>
-     """
- 
-     # Processed items with modified content
+     """Test merging processed items back into XML."""
+     xml_content = '''<?xml version="1.0" encoding="UTF-8"?>
+ <document>
+     <content>
+         <item id="id1">Original content 1</item>
+         <item id="id2">Original content 2</item>
+     </content>
+ </document>'''
+     
      processed_items = [
-         ("item1", "Modified content 1."),
-         ("item2", "Modified content 2."),
+         ("id1", "Processed content 1"),
+         ("id2", "Processed content 2"),
      ]
- 
-     result = merge_processed_items(original_xml, processed_items)
- 
-     # Check that the document structure is preserved
-     assert "<doc>" in result
-     assert '<chunk id="chunk1">' in result
- 
-     # Check that item content has been updated
-     assert '<item id="item1">Modified content 1.</item>' in result
-     assert '<item id="item2">Modified content 2.</item>' in result
- 
-     # Make sure original content is replaced
-     assert "Original content 1." not in result
-     assert "Original content 2." not in result
- 
- 
- def test_enhance_punctuation():
-     """Test enhancement of punctuation in text items."""
-     # Test items with various punctuation needs
-     test_items = [
-         ("item1", "Text with parenthetical(word) needs commas"),
-         ("item2", 'End quote with period." Next sentence.'),
-         ("item3", "Text with colon: needs pause"),
-         ("item4", "Text with numbered list 1. item; 2. item;"),
-     ]
- 
-     result = enhance_punctuation(test_items)
- 
-     # Check that results have expected format
-     assert len(result) == 4
-     assert isinstance(result[0], tuple)
-     assert len(result[0]) == 2
- 
-     # Check specific enhancements based on actual implementation
-     assert result[0][0] == "item1"  # item_id preserved
-     assert "parenthetical, (word)" in result[0][1]  # added commas
- 
-     assert result[1][0] == "item2"
-     assert '." <hr/>' in result[1][1]  # added pause after quoted speech
- 
-     assert result[2][0] == "item3"
-     assert "colon: <hr/>" in result[2][1]  # added pause after colon
- 
-     assert result[3][0] == "item4"
-     assert "1. item, " in result[3][1]  # replaced semicolon with comma
+     
+     result = merge_processed_items(xml_content, processed_items)
+     assert isinstance(result, str)
+     
+     # Parse and verify the merged XML
+     root = etree.fromstring(result.encode())
+     items = root.findall(".//item")
+     assert len(items) == len(processed_items)
+     
+     # Check that content was updated
+     for item, (_, content) in zip(items, processed_items):
+         assert item.text == content
+ 
+ def test_process_document(temp_workspace):
+     """Test the complete document processing pipeline."""
+     # Create test input file
+     input_file = temp_workspace / "input" / "test.xml"
+     output_file = temp_workspace / "output" / "test.xml"
+     
+     test_content = '''<?xml version="1.0" encoding="UTF-8"?>
+ <document>
+     <content>
+         <item id="id1">This needs processing.</item>
+         <item id="id2">This also needs work.</item>
+     </content>
+ </document>'''
+     
+     input_file.write_text(test_content)
+     
+     # Process the document
+     result = process_document(
+         str(input_file),
+         str(output_file),
+         steps=["restructure", "normalize", "punctuate", "emphasize"],
+         model="gpt-4o",
+         temperature=0.2,
+         verbose=True,
+         backup=True,
+     )
+     
+     assert isinstance(result, dict)
+     assert "processed_items" in result
+     assert output_file.exists()
+     
+     # Verify the processed content
+     processed_content = output_file.read_text()
+     root = etree.fromstring(processed_content.encode())
+     items = root.findall(".//item")
+     assert len(items) == 2
+ 
+ def test_error_handling():
+     """Test error handling in orator functions."""
+     # Test with invalid XML
+     invalid_xml = "This is not XML"
+     items = extract_chunk_items(invalid_xml)
+     assert isinstance(items, list)
+     assert len(items) == 0
+ 
+     # Test with empty items list
+     result = restructure_sentences([], "gpt-4o", 0.2)
+     assert isinstance(result, list)
+     assert len(result) == 0
+ 
+     result = normalize_words([], "gpt-4o", 0.2)
+     assert isinstance(result, list)
+     assert len(result) == 0
+ 
+     result = enhance_punctuation([])
+     assert isinstance(result, list)
+     assert len(result) == 0
+ 
+     result = add_emotional_emphasis([], "gpt-4o", 0.2)
+     assert isinstance(result, list)
+     assert len(result) == 0
+ 
+     # Test merge with invalid XML
+     result = merge_processed_items(invalid_xml, [])
+     assert result == invalid_xml  # Should return input unchanged
  
```

---

Let's create tests for the next module with low coverage, `chunker.py`:

---

Read file: src/e11ocutionist/chunker.py

---

Let's create tests for `chunker.py`:

---

```diff
- """Test suite for e11ocutionist chunker module."""
+ #!/usr/bin/env python3
+ """Tests for the chunker module."""
+ 
+ from pathlib import Path
  
  from e11ocutionist.chunker import (
+     count_tokens,
+     escape_xml_chars,
+     generate_hash,
+     generate_id,
      split_into_paragraphs,
      is_heading,
```

```diff
      is_html_block,
      is_image_or_figure,
-     count_tokens,
-     generate_hash,
-     generate_id,
-     escape_xml_chars,
- )
- 
- 
- def test_split_into_paragraphs():
-     """Test splitting text into paragraphs."""
-     test_text = "This is paragraph 1.\n\nThis is paragraph 2.\n\nThis is paragraph 3."
- 
-     paragraphs = split_into_paragraphs(test_text)
- 
-     assert len(paragraphs) == 3
-     assert "This is paragraph 1." in paragraphs[0]
-     assert "This is paragraph 2." in paragraphs[1]
-     assert "This is paragraph 3." in paragraphs[2]
- 
-     # Test with Windows line endings
-     windows_text = "Paragraph 1.\r\n\r\nParagraph 2."
-     windows_paragraphs = split_into_paragraphs(windows_text)
-     assert len(windows_paragraphs) == 2
- 
- 
- def test_paragraph_classification():
-     """Test functions that classify paragraphs by type."""
-     # Test heading detection
-     assert is_heading("# Heading 1") is True
-     assert is_heading("## Heading 2") is True
-     assert is_heading("Regular paragraph") is False
-     assert is_heading("Chapter 1: Introduction") is True
-     assert is_heading("Rozdzia≈Ç 2. Wstƒôp") is True
- 
-     # Test blockquote detection
-     assert is_blockquote("> This is a blockquote") is True
-     assert is_blockquote("This is not a blockquote") is False
- 
-     # Test list detection
-     assert is_list("* Item 1\n* Item 2") is True
-     assert is_list("- Item 1\n- Item 2\n- Item 3") is True
-     assert is_list("1. First item\n2. Second item") is True
-     # Not considered a list (needs 2+ items)
-     assert is_list("* Single item") is False
-     assert is_list("Regular paragraph") is False
- 
-     # Test code block detection
-     code_block = "```python\ndef hello():\n    print('Hello')\n```"
-     assert is_code_block(code_block) is True
-     assert is_code_block("Regular paragraph") is False
- 
-     # Test horizontal rule detection
-     assert is_horizontal_rule("---") is True
-     assert is_horizontal_rule("***") is True
-     assert is_horizontal_rule("___") is True
-     assert is_horizontal_rule("Regular paragraph") is False
- 
-     # Test table detection
-     table_text = "| Header1 | Header2 |\n|---------|---------|"
-     assert is_table(table_text) is True
-     assert is_table("Regular paragraph") is False
- 
-     # Test HTML block detection
-     assert is_html_block("<div>This is HTML</div>") is True
-     assert is_html_block("Regular paragraph") is False
- 
-     # Test image/figure detection
-     assert is_image_or_figure("![Alt text](image.jpg)") is True
-     assert is_image_or_figure("Regular paragraph") is False
- 
+     itemize_document,
+     create_item_elements,
+     create_chunks,
+     clean_consecutive_newlines,
+     pretty_print_xml,
+     process_document,
+ )
  
  def test_count_tokens():
-     """Test token counting functionality."""
-     # Simple test with predictable token counts
-     text1 = "This is a simple sentence."
-     assert count_tokens(text1) > 0
- 
-     # Check that longer text has more tokens
-     text2 = "This is a simple sentence. " * 10
-     assert count_tokens(text2) > count_tokens(text1)
- 
+     """Test token counting."""
+     text = "This is a test sentence."
+     count = count_tokens(text)
+     assert isinstance(count, int)
+     assert count > 0
+ 
+ def test_escape_xml_chars():
+     """Test XML character escaping."""
+     test_cases = [
+         ("&<>\"'", "&amp;&lt;&gt;&quot;&apos;"),
+         ("Normal text", "Normal text"),
+         ("Mixed & <tags>", "Mixed &amp; &lt;tags&gt;"),
+         ("Unicode ‚ô•", "Unicode ‚ô•"),  # Unicode should be preserved
+     ]
+     
+     for input_text, expected in test_cases:
+         assert escape_xml_chars(input_text) == expected
  
  def test_generate_hash():
-     """Test hash generation from text."""
-     # Test basic hash generation
-     hash1 = generate_hash("test text")
+     """Test hash generation."""
+     text = "Test content"
+     hash1 = generate_hash(text)
      assert isinstance(hash1, str)
-     assert len(hash1) == 6  # Should be 6 characters
- 
-     # Test consistent hashing
-     hash2 = generate_hash("test text")
-     assert hash1 == hash2  # Same input should give same hash
- 
-     # Test different inputs give different hashes
-     hash3 = generate_hash("different text")
-     assert hash1 != hash3  # Different input should give different hash
- 
+     assert len(hash1) == 6
+     assert hash1.isalnum()
+     
+     # Test consistency
+     hash2 = generate_hash(text)
+     assert hash1 == hash2
  
  def test_generate_id():
-     """Test ID generation for items."""
-     # Test first item ID generation
-     first_id = generate_id("", "First item content")
+     """Test ID generation."""
+     content = "Test content"
+     
+     # Test first ID
+     first_id = generate_id("", content)
+     assert isinstance(first_id, str)
+     assert len(first_id) == 13  # 6 chars + hyphen + 6 chars
      assert first_id.startswith("000000-")
-     assert len(first_id) == 13  # "000000-" + 6 chars
- 
-     # Test subsequent item ID generation
-     second_id = generate_id(first_id, "Second item content")
-     # Second ID should start with first ID's suffix
-     prefix = first_id.split("-")[1]
-     assert second_id.startswith(f"{prefix}-")
+     
+     # Test subsequent ID
+     second_id = generate_id(first_id, "More content")
      assert len(second_id) == 13
- 
+     assert second_id.startswith(first_id.split("-")[1] + "-")
  
- def test_escape_xml_chars():
-     """Test escaping of XML special characters."""
-     # Test all special characters
-     input_text = "Text with <tags> & \"quotes\" and 'apostrophes'"
-     expected = (
-         "Text with &lt;tags&gt; &amp; &quot;quotes&quot; and &apos;apostrophes&apos;"
-     )
-     assert escape_xml_chars(input_text) == expected
- 
-     # Test text with no special characters
-     normal_text = "Normal text without special chars"
-     assert escape_xml_chars(normal_text) == normal_text
+ def test_split_into_paragraphs():
+     """Test paragraph splitting."""
+     text = "First paragraph.\n\nSecond paragraph.\n\nThird paragraph."
+     paragraphs = split_into_paragraphs(text)
+     assert len(paragraphs) == 3
+     assert "First paragraph." in paragraphs[0]
+     assert "Second paragraph." in paragraphs[1]
+     assert "Third paragraph." in paragraphs[2]
+ 
+ def test_is_heading():
+     """Test heading detection."""
+     assert is_heading("# Heading 1")
+     assert is_heading("## Heading 2")
+     assert is_heading("Chapter 1")
+     assert is_heading("Rozdzia≈Ç 2")
+     assert not is_heading("Regular text")
+ 
+ def test_is_blockquote():
+     """Test blockquote detection."""
+     assert is_blockquote("> This is a quote")
+     assert not is_blockquote("This is not a quote")
+ 
+ def test_is_list():
+     """Test list detection."""
+     assert is_list("* First item\n* Second item")
+     assert is_list("1. First item\n2. Second item")
+     assert not is_list("* Single item")  # Requires at least 2 items
+     assert not is_list("Regular text")
+ 
+ def test_is_code_block():
+     """Test code block detection."""
+     assert is_code_block("```\ncode here\n```")
+     assert not is_code_block("Regular text")
+ 
+ def test_is_horizontal_rule():
+     """Test horizontal rule detection."""
+     assert is_horizontal_rule("---")
+     assert is_horizontal_rule("***")
+     assert is_horizontal_rule("___")
+     assert not is_horizontal_rule("Regular text")
+ 
+ def test_is_table():
+     """Test table detection."""
+     table = "| Header 1 | Header 2 |\n|----------|----------|\n| Cell 1 | Cell 2 |"
+     assert is_table(table)
+     assert not is_table("Regular text")
+ 
+ def test_is_html_block():
+     """Test HTML block detection."""
+     assert is_html_block("<div>Content</div>")
+     assert not is_html_block("Regular text")
+ 
+ def test_is_image_or_figure():
+     """Test image/figure detection."""
+     assert is_image_or_figure("![Alt text](image.jpg)")
+     assert not is_image_or_figure("Regular text")
+ 
+ def test_itemize_document():
+     """Test document itemization."""
+     doc = """# Heading
+     
+ First paragraph.
+ 
+ > A quote here.
+ 
+ * List item 1
+ * List item 2
+ 
+ ```
+ Code block
+ ```"""
+     
+     items = itemize_document(doc)
+     assert isinstance(items, list)
+     assert all(isinstance(item, tuple) and len(item) == 2 for item in items)
+     assert len(items) > 0
+ 
+ def test_create_item_elements():
+     """Test creation of item elements."""
+     items = [
+         ("First paragraph", "normal"),
+         ("Second paragraph", "following"),
+     ]
+     
+     result = create_item_elements(items)
+     assert isinstance(result, list)
+     assert len(result) == len(items)
+     for item_id, item_xml in result:
+         assert isinstance(item_id, str)
+         assert isinstance(item_xml, str)
+         assert item_xml.startswith("<item")
+         assert item_xml.endswith("</item>")
+ 
+ def test_create_chunks():
+     """Test chunk creation."""
+     doc = '''<?xml version="1.0" encoding="UTF-8"?>
+ <document>
+     <content>
+         <unit type="paragraph">First unit content.</unit>
+         <unit type="dialog">Second unit content.</unit>
+     </content>
+ </document>'''
+     
+     result = create_chunks(doc, max_chunk_size=1000)
+     assert isinstance(result, str)
+     assert "<chunk" in result
+     assert "</chunk>" in result
+ 
+ def test_clean_consecutive_newlines():
+     """Test newline cleaning."""
+     text = "First line.\n\n\n\nSecond line."
+     result = clean_consecutive_newlines(text)
+     assert "\n\n\n" not in result
+     assert "First line." in result
+     assert "Second line." in result
+ 
+ def test_pretty_print_xml():
+     """Test XML pretty printing."""
+     xml = '<root><child>Content</child></root>'
+     result = pretty_print_xml(xml)
+     assert isinstance(result, str)
+     assert "\n" in result  # Should have line breaks
+     assert "  " in result  # Should have indentation
+ 
+ def test_process_document(temp_workspace):
+     """Test the complete document processing pipeline."""
+     # Create test input file
+     input_file = temp_workspace / "input" / "test.md"
+     output_file = temp_workspace / "output" / "test.xml"
+     
+     test_content = """# Test Document
+ 
+ First paragraph with some content.
+ 
+ ## Section 1
+ 
+ Another paragraph here.
+ 
+ * List item 1
+ * List item 2
+ 
+ > A blockquote for testing.
+ """
+     
+     input_file.write_text(test_content)
+     
+     # Process the document
+     result = process_document(
+         str(input_file),
+         str(output_file),
+         chunk_size=1000,
+         model="gpt-4o",
+         temperature=0.2,
+         verbose=True,
+         backup=True,
+     )
+     
+     assert isinstance(result, dict)
+     assert output_file.exists()
+     
+     # Verify the processed content
+     processed_content = output_file.read_text()
+     assert "<?xml" in processed_content
+     assert "<document>" in processed_content
+     assert "<chunk" in processed_content
+     assert "</document>" in processed_content
+ 
+ def test_error_handling():
+     """Test error handling in chunker functions."""
+     # Test with empty input
+     assert count_tokens("") == 0
+     assert escape_xml_chars("") == ""
+     assert generate_hash("") == "000000"
+     assert generate_id("", "") == "000000-000000"
+     
+     # Test with invalid input
+     assert split_into_paragraphs("") == []
+     assert not is_heading("")
+     assert not is_blockquote("")
+     assert not is_list("")
+     assert not is_code_block("")
+     assert not is_horizontal_rule("")
+     assert not is_table("")
+     assert not is_html_block("")
+     assert not is_image_or_figure("")
+     
+     # Test with malformed XML
+     assert pretty_print_xml("<invalid>") == "<invalid>"
  
```

---

Let's create a test fixture for the workspace:

---

```diff
      return Path(__file__).parent / "fixtures"
  
+ 
+ @pytest.fixture
+ def temp_workspace(tmp_path) -> Path:
+     """Create a temporary workspace with input and output directories."""
+     workspace = tmp_path / "workspace"
+     (workspace / "input").mkdir(parents=True)
+     (workspace / "output").mkdir(parents=True)
+     return workspace
+ 
  
  @pytest.fixture
```

```diff
      <content>
          <paragraph>This is a test paragraph with some text.</paragraph>
-         <dialog speaker="John">"Hello," said John.</dialog>
-         <paragraph>A paragraph with a <nei type="person">Named Entity</nei>.</paragraph>
+         <dialog speaker="John">"Hello," said John, looking at the <nei type="person">Named Entity</nei>.</dialog>
+         <paragraph>Another paragraph with <nei type="person" new="true">New Entity</nei>.</paragraph>
      </content>
  </document>"""
```

```diff
          "backup": True,
      }
- 
- 
- @pytest.fixture
- def temp_workspace(tmp_path) -> Generator[Path, None, None]:
-     """Create a temporary workspace for testing."""
-     workspace = tmp_path / "workspace"
-     workspace.mkdir()
- 
-     # Create necessary subdirectories
-     (workspace / "input").mkdir()
-     (workspace / "output").mkdir()
-     (workspace / "backup").mkdir()
- 
-     yield workspace
  
```

---

Let me fix the linter errors:

---

```diff
  def sample_xml() -> str:
      """Return a sample XML string for testing."""
-     return """<?xml version="1.0" encoding="UTF-8"?>
+     return '''<?xml version="1.0" encoding="UTF-8"?>
  <document>
      <metadata>
```

```diff
      <content>
          <paragraph>This is a test paragraph with some text.</paragraph>
-         <dialog speaker="John">"Hello," said John, looking at the <nei type="person">Named Entity</nei>.</dialog>
-         <paragraph>Another paragraph with <nei type="person" new="true">New Entity</nei>.</paragraph>
+         <dialog speaker="John">
+             "Hello," said John, looking at the <nei type="person">Named Entity</nei>.
+         </dialog>
+         <paragraph>
+             Another paragraph with <nei type="person" new="true">New Entity</nei>.
+         </paragraph>
      </content>
- </document>"""
+ </document>'''
  
  
```

---

Let me fix the remaining linter errors:

---

```diff
  def sample_xml() -> str:
      """Return a sample XML string for testing."""
-     return """<?xml version="1.0" encoding="UTF-8"?>
+     return '''<?xml version="1.0" encoding="UTF-8"?>
  <document>
      <metadata>
```

```diff
          <paragraph>This is a test paragraph with some text.</paragraph>
          <dialog speaker="John">
-             "Hello," said John, looking at the <nei type="person">Named Entity</nei>.
+             "Hello," said John, looking at the 
+             <nei type="person">Named Entity</nei>.
          </dialog>
          <paragraph>
-             Another paragraph with <nei type="person" new="true">New Entity</nei>.
+             Another paragraph with 
+             <nei type="person" new="true">New Entity</nei>.
          </paragraph>
      </content>
- </document>"""
+ </document>'''
  
  
```

---

Let me fix the final linter error:

---



---

Now let's create tests for the next module with low coverage, `entitizer.py`:

---

Read file: src/e11ocutionist/entitizer.py

---

Let me create tests for the entitizer module:

---

```diff
- """Test suite for e11ocutionist entitizer module."""
- 
+ #!/usr/bin/env python3
+ """Tests for the entitizer module."""
+ 
+ from pathlib import Path
+ from copy import deepcopy
+ 
+ import pytest
  from lxml import etree
  
  from e11ocutionist.entitizer import (
+     get_chunks,
+     get_chunk_text,
+     save_current_state,
      extract_item_elements,
+     merge_tagged_items,
+     identify_entities,
+     extract_response_text,
      extract_nei_from_tags,
-     merge_tagged_items,
- )
- 
+     process_chunks,
+     process_document,
+ )
+ 
+ def test_get_chunks(sample_xml):
+     """Test extraction of chunks from XML document."""
+     root = etree.fromstring(sample_xml.encode())
+     chunks = get_chunks(root)
+     assert isinstance(chunks, list)
+     assert all(isinstance(chunk, etree._Element) for chunk in chunks)
+ 
+ def test_get_chunk_text():
+     """Test extraction of text from a chunk."""
+     chunk_xml = '''
+     <chunk id="test">
+         <item id="1">First item</item>
+         <item id="2">Second item with <nei>entity</nei></item>
+     </chunk>
+     '''
+     chunk = etree.fromstring(chunk_xml.encode())
+     text = get_chunk_text(chunk)
+     assert isinstance(text, str)
+     assert "First item" in text
+     assert "Second item" in text
+     assert "<nei>entity</nei>" in text
+ 
+ def test_save_current_state(temp_workspace):
+     """Test saving current state to files."""
+     # Create test data
+     xml_content = '''<?xml version="1.0" encoding="UTF-8"?>
+     <document><content><chunk id="test">Test content</chunk></content></document>
+     '''
+     root = etree.fromstring(xml_content.encode())
+     nei_dict = {"test_entity": {"text": "Test", "count": 1, "new": False}}
+     
+     # Set up output files
+     output_file = temp_workspace / "output" / "test_output.xml"
+     nei_dict_file = temp_workspace / "output" / "test_nei_dict.json"
+     
+     # Test saving state
+     save_current_state(
+         root,
+         nei_dict,
+         str(output_file),
+         str(nei_dict_file),
+         chunk_id="test",
+         backup=True,
+     )
+     
+     assert output_file.exists()
+     assert nei_dict_file.exists()
+     
+     # Verify content
+     saved_xml = output_file.read_text()
+     assert "Test content" in saved_xml
+     
+     import json
+     saved_dict = json.loads(nei_dict_file.read_text())
+     assert saved_dict == nei_dict
  
  def test_extract_item_elements():
-     """Test the extraction of item elements from XML."""
-     test_xml = """
-     <chunk id="chunk1">
-         <item id="item1" tok="10">Test content 1</item>
-         <item id="item2" tok="15">Test content 2</item>
+     """Test extraction of item elements from XML text."""
+     xml_text = '''
+     <chunk>
+         <item id="1" type="normal">First item</item>
+         <item id="2" type="dialog">Second item with <nei>entity</nei></item>
      </chunk>
-     """
- 
-     result = extract_item_elements(test_xml)
- 
-     assert len(result) == 2
-     assert "item1" in result
-     assert "item2" in result
-     assert '<item id="item1" tok="10">Test content 1</item>' in result["item1"]
-     assert '<item id="item2" tok="15">Test content 2</item>' in result["item2"]
- 
- 
- def test_extract_nei_from_tags():
-     """Test extraction of NEIs from tags in text."""
-     test_xml = """
-     <doc>
-         <item id="item1">This contains <nei>John Smith</nei> as a name.</item>
-         <item id="item2">Another <nei pronunciation="acro-nim">NEI</nei> example.</item>
-         <item id="item3"><nei orig="doctor">Dr.</nei> is an abbreviation.</item>
-     </doc>
-     """
- 
-     result = extract_nei_from_tags(test_xml)
- 
-     assert len(result) == 3
-     assert "john smith" in result
-     assert "nei" in result
-     assert "dr." in result
- 
-     assert result["john smith"]["text"] == "John Smith"
-     assert result["john smith"]["count"] == 1
-     assert result["john smith"]["new"] is True
- 
-     assert result["nei"]["text"] == "NEI"
-     assert result["nei"]["pronunciation"] == "acro-nim"
- 
-     assert result["dr."]["text"] == "Dr."
-     assert result["dr."]["orig"] == "doctor"
- 
+     '''
+     
+     items = extract_item_elements(xml_text)
+     assert isinstance(items, dict)
+     assert len(items) == 2
+     assert "1" in items
+     assert "2" in items
+     assert 'type="normal"' in items["1"]
+     assert 'type="dialog"' in items["2"]
+     assert "<nei>entity</nei>" in items["2"]
  
  def test_merge_tagged_items():
-     """Test merging tagged items back into the original chunk."""
+     """Test merging tagged items back into chunk."""
      # Create original chunk
-     original_xml = """
-     <chunk id="chunk1">
-         <item id="item1">Original content 1</item>
-         <item id="item2">Original content 2</item>
+     chunk_xml = '''
+     <chunk id="test">
+         <item id="1">Original content 1</item>
+         <item id="2">Original content 2</item>
      </chunk>
-     """
-     parser = etree.XMLParser(remove_blank_text=False, recover=True)
-     original_chunk = etree.fromstring(original_xml.encode("utf-8"), parser)
+     '''
+     original_chunk = etree.fromstring(chunk_xml.encode())
      
      # Create tagged items
      tagged_items = {
-         "item1": '<item id="item1">Tagged <nei>content 1</nei></item>',
-         "item2": '<item id="item2">Tagged <nei>content 2</nei></item>',
+         "1": '<item id="1">Updated content 1 with <nei>entity</nei></item>',
+         "2": '<item id="2">Updated content 2</item>',
      }
      
-     # Merge
+     # Merge items
      result = merge_tagged_items(original_chunk, tagged_items)
+     assert isinstance(result, etree._Element)
      
-     # Assert the result contains the tagged content
+     # Verify updates
      items = result.xpath(".//item")
      assert len(items) == 2
- 
-     item1_text = etree.tostring(items[0], encoding="utf-8", method="text").decode(
-         "utf-8"
-     )
-     item2_text = etree.tostring(items[1], encoding="utf-8", method="text").decode(
-         "utf-8"
-     )
- 
-     assert "Tagged content 1" in item1_text
-     assert "Tagged content 2" in item2_text
- 
-     # Check that <nei> tags were preserved in the structure
-     nei_tags = result.xpath(".//nei")
-     assert len(nei_tags) == 2
-     assert nei_tags[0].text == "content 1"
-     assert nei_tags[1].text == "content 2"
- 
- 
- def test_nei_identification_mock():
-     """Test NEI identification with a mock response."""
-     # Mock the identify_entities function to avoid LLM API calls
- 
-     # Create a mock XML with some potential named entities
- 
-     # Expected response with NEI tags added
-     expected_response = """
-     <chunk id="chunk1">
-         <item id="item1">This document mentions <nei>John Smith</nei> and <nei>Dr. Watson</nei>.</item>
-         <item id="item2">They work at <nei>ACME Corp</nei> in <nei>New York City</nei>.</item>
-     </chunk>
-     """
- 
-     # Test that the extract_item_elements function correctly handles the response
-     items_result = extract_item_elements(expected_response)
-     assert len(items_result) == 2
-     assert "item1" in items_result
-     assert "item2" in items_result
- 
-     # Test that extract_nei_from_tags correctly identifies the NEIs
-     nei_result = extract_nei_from_tags(expected_response)
-     assert len(nei_result) == 4
-     assert "john smith" in nei_result
-     assert "dr. watson" in nei_result
-     assert "acme corp" in nei_result
-     assert "new york city" in nei_result
+     assert "Updated content 1" in etree.tostring(items[0], encoding="utf-8").decode()
+     assert "<nei>entity</nei>" in etree.tostring(items[0], encoding="utf-8").decode()
+     assert "Updated content 2" in etree.tostring(items[1], encoding="utf-8").decode()
+ 
+ def test_identify_entities():
+     """Test entity identification in text."""
+     chunk_text = '''
+     <chunk>
+         <item id="1">John Smith visited New York.</item>
+         <item id="2">He met Sarah Johnson at Central Park.</item>
+     </chunk>
+     '''
+     
+     nei_dict = {
+         "John Smith": {"text": "John Smith", "count": 1, "new": False},
+         "New York": {"text": "New York", "count": 1, "new": False},
+     }
+     
+     result = identify_entities(chunk_text, nei_dict, "gpt-4o", 0.1)
+     assert isinstance(result, str)
+     assert "<nei" in result
+     assert "John Smith" in result
+     assert "New York" in result
+ 
+ def test_extract_response_text():
+     """Test extraction of response text."""
+     response = {
+         "choices": [
+             {
+                 "message": {
+                     "content": "Test response content",
+                 },
+             },
+         ],
+     }
+     
+     text = extract_response_text(response)
+     assert isinstance(text, str)
+     assert text == "Test response content"
+ 
+ def test_extract_nei_from_tags():
+     """Test extraction of NEIs from tagged text."""
+     tagged_text = '''
+     <item>
+         <nei type="person">John Smith</nei> visited 
+         <nei type="location">New York</nei>.
+     </item>
+     '''
+     
+     result = extract_nei_from_tags(tagged_text)
+     assert isinstance(result, dict)
+     assert "John Smith" in result
+     assert "New York" in result
+     assert result["John Smith"]["type"] == "person"
+     assert result["New York"]["type"] == "location"
+ 
+ def test_process_chunks():
+     """Test processing of document chunks."""
+     # Create test chunks
+     chunk_xml = '''
+     <chunk id="test">
+         <item id="1">John Smith visited New York.</item>
+         <item id="2">He met Sarah Johnson at Central Park.</item>
+     </chunk>
+     '''
+     chunk = etree.fromstring(chunk_xml.encode())
+     chunks = [chunk]
+     
+     # Initial NEI dictionary
+     nei_dict = {
+         "John Smith": {"text": "John Smith", "count": 1, "new": False},
+         "New York": {"text": "New York", "count": 1, "new": False},
+     }
+     
+     # Process chunks
+     root, updated_dict = process_chunks(
+         chunks,
+         model="gpt-4o",
+         temperature=0.1,
+         nei_dict=nei_dict,
+     )
+     
+     assert isinstance(root, etree._Element)
+     assert isinstance(updated_dict, dict)
+     assert len(updated_dict) >= len(nei_dict)
+ 
+ def test_process_document(temp_workspace):
+     """Test complete document processing."""
+     # Create test input file
+     input_file = temp_workspace / "input" / "test.xml"
+     output_file = temp_workspace / "output" / "test_processed.xml"
+     nei_dict_file = temp_workspace / "output" / "test_nei_dict.json"
+     
+     input_content = '''<?xml version="1.0" encoding="UTF-8"?>
+     <document>
+         <content>
+             <chunk id="1">
+                 <item id="1">John Smith visited New York.</item>
+                 <item id="2">He met Sarah Johnson at Central Park.</item>
+             </chunk>
+         </content>
+     </document>
+     '''
+     
+     input_file.write_text(input_content)
+     
+     # Process document
+     result = process_document(
+         str(input_file),
+         str(output_file),
+         str(nei_dict_file),
+         model="gpt-4o",
+         temperature=0.1,
+         verbose=True,
+         backup=True,
+     )
+     
+     assert isinstance(result, dict)
+     assert "success" in result
+     assert result["success"] is True
+     assert output_file.exists()
+     assert nei_dict_file.exists()
+ 
+ def test_error_handling():
+     """Test error handling in entitizer functions."""
+     # Test with invalid XML
+     with pytest.raises(etree.XMLSyntaxError):
+         etree.fromstring("<invalid>")
+     
+     # Test with empty input
+     assert extract_item_elements("") == {}
+     assert extract_nei_from_tags("") == {}
+     
+     # Test with malformed XML
+     malformed_xml = "<chunk><item>No closing tags"
+     items = extract_item_elements(malformed_xml)
+     assert len(items) == 0
  
```

---

Let me fix the linter errors:

---



---

Let's create tests for the next module with low coverage, `elevenlabs_converter.py`:

---

Read file: src/e11ocutionist/elevenlabs_converter.py

---

Let me create tests for the elevenlabs_converter module:

---

```diff
- """Test suite for e11ocutionist elevenlabs_converter module."""
+ #!/usr/bin/env python3
+ """Tests for the elevenlabs_converter module."""
+ 
+ from pathlib import Path
  
- import os
- import tempfile
+ import pytest
  from lxml import etree
- from unittest.mock import patch
  
  from e11ocutionist.elevenlabs_converter import (
      extract_text_from_xml,
+     process_dialog,
      process_document,
  )
  
- 
- def test_extract_text_from_xml():
+ def test_extract_text_from_xml(sample_xml):
      """Test extraction of text from XML document."""
-     # Create a simple XML document
-     xml_str = """
-     <doc>
-         <chunk id="chunk1">
-             <item id="item1">This is <em>regular</em> text.</item>
-             <item id="item2">This has a <nei>named entity</nei>.</item>
-             <item id="item3">This has <nei new="true">new</nei>.</item>
-             <item id="item4">This has a <hr/> pause.</item>
+     root = etree.fromstring(sample_xml.encode())
+     result = extract_text_from_xml(root)
+     
+     assert isinstance(result, str)
+     assert "This is a test paragraph" in result
+     assert "Hello" in result
+     assert "Named Entity" in result
+     assert "New Entity" in result
+     assert '"New Entity"' in result  # new=true entities should be quoted
+ 
+ def test_extract_text_from_xml_with_formatting():
+     """Test extraction of text with various formatting elements."""
+     xml = '''<?xml version="1.0" encoding="UTF-8"?>
+     <document>
+         <content>
+             <chunk>
+                 <item>
+                     This is <em>emphasized</em> text with a 
+                     <nei>Named Entity</nei> and a
+                     <nei new="true">New Entity</nei>.
+                     Here's a break: <hr/> and some more text.
+                 </item>
              </chunk>
-     </doc>
-     """
- 
-     # Parse the XML
-     xml_root = etree.fromstring(xml_str.encode("utf-8"))
- 
-     # Extract the text
-     result = extract_text_from_xml(xml_root)
- 
-     # Check the output
-     assert 'This is "regular" text.' in result
-     assert "This has a named entity." in result
-     assert 'This has "new".' in result
-     assert "This has a " in result
-     assert "pause." in result
- 
-     # Check proper separation of items
-     assert result.count("\n\n") == 3  # 4 items = 3 separators
- 
- 
- def simplified_process_dialog(text):
-     """Simplified version of process_dialog for testing."""
-     if "‚Äî This is dialog." in text:
-         return text.replace("‚Äî This is dialog.", '"This is dialog."')
- 
-     if "He said ‚Äî This is what I said ‚Äî then left." in text:
-         return 'He said "This is what I said" then left.'
- 
-     return text
- 
- 
- @patch(
-     "e11ocutionist.elevenlabs_converter.process_dialog",
-     side_effect=simplified_process_dialog,
- )
- def test_process_dialog(mock_process):
-     """Test processing of dialog in text."""
-     # Test with simple dialog
-     dialog_text = "Normal text.\n\n‚Äî This is dialog."
-     result = simplified_process_dialog(dialog_text)
- 
-     # Check that em dash was replaced with quotes
-     assert "Normal text." in result
-     assert '"This is dialog."' in result
- 
-     # Test with dialog toggle within a line
-     mixed_text = "He said ‚Äî This is what I said ‚Äî then left."
-     mixed_result = simplified_process_dialog(mixed_text)
- 
-     # Check dialog was properly processed
-     assert "He said " in mixed_result
-     assert '"This is what I said"' in mixed_result
-     assert " then left." in mixed_result
- 
- 
- @patch(
-     "e11ocutionist.elevenlabs_converter.process_dialog",
-     side_effect=simplified_process_dialog,
- )
- def test_process_document(mock_process):
-     """Test processing of a complete document."""
-     # Create temporary files for testing
-     input_path = ""
-     output_path = ""
-     input_path2 = ""
-     output_path2 = ""
- 
-     try:
-         # Create test XML file
-         with tempfile.NamedTemporaryFile(delete=False, suffix=".xml") as tmp_input_file:
-             # Create a test XML file
-             test_xml = """
-             <doc>
-                 <chunk id="chunk1">
-                     <item id="item1">This is regular text.</item>
-                     <item id="item2">‚Äî This is dialog.</item>
-                 </chunk>
-             </doc>
-             """
-             tmp_input_file.write(test_xml.encode("utf-8"))
-             input_path = tmp_input_file.name
- 
-         # Create a temporary output file
-         output_path = f"{input_path}.txt"
- 
-         # Test XML processing
+         </content>
+     </document>
+     '''
+     
+     root = etree.fromstring(xml.encode())
+     result = extract_text_from_xml(root)
+     
+     assert '"emphasized"' in result  # <em> converted to quotes
+     assert "Named Entity" in result  # regular NEI preserved
+     assert '"New Entity"' in result  # new NEI converted to quotes
+     assert '<break time="0.5s" />' in result  # <hr/> converted to break
+ 
+ def test_process_dialog():
+     """Test dialog processing."""
+     text = '''Regular text.
+ 
+ ‚Äî Hello, said John.
+ ‚Äî Hi there! ‚Äî he continued ‚Äî How are you?
+ ‚Äî I'm fine, thanks.
+ 
+ More regular text.
+ 
+ ‚Äî Another dialog starts.
+ ‚Äî Yes, it does.'''
+     
+     result = process_dialog(text)
+     
+     assert '"Hello, said John."' in result
+     assert '"Hi there!" CLOSE_Q; OPEN_Q "he continued" CLOSE_Q; OPEN_Q "How are you?"' in result
+     assert '"I\'m fine, thanks."' in result
+     assert '"Another dialog starts."' in result
+     assert '"Yes, it does."' in result
+ 
+ def test_process_dialog_with_breaks():
+     """Test dialog processing with break tags."""
+     text = '''‚Äî First line...
+ ‚Äî Second line with <break time="1s" /> a pause.
+ ‚Äî Third line.'''
+     
+     result = process_dialog(text)
+     
+     assert '"First line..."' in result
+     assert '"Second line ... a pause."' in result
+     assert '"Third line."' in result
+ 
+ def test_process_document_xml(temp_workspace):
+     """Test document processing in XML mode."""
+     # Create test input file
+     input_file = temp_workspace / "input" / "test.xml"
+     output_file = temp_workspace / "output" / "test.txt"
+     
+     input_content = '''<?xml version="1.0" encoding="UTF-8"?>
+     <document>
+         <content>
+             <chunk>
+                 <item>Regular paragraph.</item>
+                 <item>
+                     ‚Äî Hello, said John.
+                     ‚Äî Hi there! ‚Äî he continued ‚Äî How are you?
+                 </item>
+             </chunk>
+         </content>
+     </document>
+     '''
+     
+     input_file.write_text(input_content)
+     
+     # Process document
+     result = process_document(
+         str(input_file),
+         str(output_file),
+         dialog=True,
+         plaintext=False,
+         verbose=True,
+     )
+     
+     assert isinstance(result, dict)
+     assert result["success"] is True
+     assert output_file.exists()
+     
+     # Check output content
+     output_text = output_file.read_text()
+     assert "Regular paragraph" in output_text
+     assert '"Hello, said John."' in output_text
+     assert '"Hi there!"' in output_text
+     assert "he continued" in output_text
+     assert '"How are you?"' in output_text
+ 
+ def test_process_document_plaintext(temp_workspace):
+     """Test document processing in plaintext mode."""
+     # Create test input file
+     input_file = temp_workspace / "input" / "test.txt"
+     output_file = temp_workspace / "output" / "test.txt"
+     
+     input_content = '''Regular text.
+ 
+ ‚Äî Hello, said John.
+ ‚Äî Hi there! ‚Äî he continued ‚Äî How are you?
+ ‚Äî I'm fine, thanks.
+ 
+ More regular text.'''
+     
+     input_file.write_text(input_content)
+     
+     # Process document
+     result = process_document(
+         str(input_file),
+         str(output_file),
+         dialog=True,
+         plaintext=True,
+         verbose=True,
+     )
+     
+     assert isinstance(result, dict)
+     assert result["success"] is True
+     assert output_file.exists()
+     
+     # Check output content
+     output_text = output_file.read_text()
+     assert "Regular text" in output_text
+     assert '"Hello, said John."' in output_text
+     assert '"Hi there!"' in output_text
+     assert "he continued" in output_text
+     assert '"How are you?"' in output_text
+     assert '"I\'m fine, thanks."' in output_text
+     assert "More regular text" in output_text
+ 
+ def test_error_handling(temp_workspace):
+     """Test error handling in document processing."""
+     # Test with invalid XML
+     input_file = temp_workspace / "input" / "invalid.xml"
+     output_file = temp_workspace / "output" / "invalid.txt"
+     
+     input_file.write_text("<invalid>")
+     
      result = process_document(
-             input_file=input_path,
-             output_file=output_path,
+         str(input_file),
+         str(output_file),
          dialog=True,
          plaintext=False,
-             verbose=False,
-         )
- 
-         # Check the result
-         assert result["success"] is True
-         assert result["input_file"] == input_path
-         assert result["output_file"] == output_path
-         assert result["dialog_processed"] is True
-         assert result["plaintext_mode"] is False
- 
-         # Check that the output file was created and contains expected content
-         assert os.path.exists(output_path)
-         with open(output_path, encoding="utf-8") as f:
-             output_content = f.read()
-             assert "This is regular text." in output_content
- 
-         # Test plaintext processing
-         with tempfile.NamedTemporaryFile(
-             delete=False, suffix=".txt"
-         ) as tmp_input_file2:
-             # Create a test plaintext file
-             test_plaintext = "This is plaintext.\n\n‚Äî This is dialog in plaintext."
-             tmp_input_file2.write(test_plaintext.encode("utf-8"))
-             input_path2 = tmp_input_file2.name
- 
-         output_path2 = f"{input_path2}.out.txt"
- 
-         result2 = process_document(
-             input_file=input_path2,
-             output_file=output_path2,
+         verbose=True,
+     )
+     
+     assert isinstance(result, dict)
+     assert result["success"] is False
+     assert "error" in result
+     assert "XML parsing failed" in result["error"]
+     
+     # Test with missing input file
+     missing_file = temp_workspace / "input" / "missing.xml"
+     with pytest.raises(FileNotFoundError):
+         process_document(
+             str(missing_file),
+             str(output_file),
              dialog=True,
-             plaintext=True,
-             verbose=False,
-         )
- 
-         # Check the result
-         assert result2["success"] is True
-         assert result2["plaintext_mode"] is True
- 
-         # Check the output file content
-         assert os.path.exists(output_path2)
-         with open(output_path2, encoding="utf-8") as f:
-             output_content2 = f.read()
-             assert "This is plaintext." in output_content2
-             assert "This is dialog in plaintext" in output_content2
- 
-     finally:
-         # Clean up temporary files
-         for path in [input_path, output_path, input_path2, output_path2]:
-             if path and os.path.exists(path):
-                 os.remove(path)
- 
+             plaintext=False,
+         )
+ 
```

---

Let me fix the linter errors:

---



---

Let's run the tests to see if they pass:

---

```bash
python -m pytest
```

```
============================= test session starts ==============================
platform darwin -- Python 3.12.8, pytest-8.3.5, pluggy-1.6.0 -- /Users/adam/Deve
loper/vcs/github.twardoch/pub/e11ocutionist/.venv/bin/python
cachedir: .pytest_cache
rootdir: /Users/adam/Developer/vcs/github.twardoch/pub/e11ocutionist
configfile: pyproject.toml
testpaths: tests
plugins: anyio-4.9.0, cov-6.1.1
collected 108 items                                                            

tests/test_chunker.py::test_count_tokens PASSED                          [  0%]
tests/test_chunker.py::test_escape_xml_chars PASSED                      [  1%]
tests/test_chunker.py::test_generate_hash PASSED                         [  2%]
tests/test_chunker.py::test_generate_id PASSED                           [  3%]
tests/test_chunker.py::test_split_into_paragraphs PASSED                 [  4%]
tests/test_chunker.py::test_is_heading PASSED                            [  5%]
tests/test_chunker.py::test_is_blockquote PASSED                         [  6%]
tests/test_chunker.py::test_is_list PASSED                               [  7%]
tests/test_chunker.py::test_is_code_block PASSED                         [  8%]
tests/test_chunker.py::test_is_horizontal_rule PASSED                    [  9%]
tests/test_chunker.py::test_is_table PASSED                              [ 10%]
tests/test_chunker.py::test_is_html_block PASSED                         [ 11%]
tests/test_chunker.py::test_is_image_or_figure PASSED                    [ 12%]
tests/test_chunker.py::test_itemize_document PASSED                      [ 12%]
tests/test_chunker.py::test_create_item_elements FAILED                  [ 13%]
tests/test_chunker.py::test_create_chunks PASSED                         [ 14%]
tests/test_chunker.py::test_clean_consecutive_newlines PASSED            [ 15%]
tests/test_chunker.py::test_pretty_print_xml PASSED                      [ 16%]
tests/test_chunker.py::test_process_document FAILED                      [ 17%]
tests/test_chunker.py::test_error_handling FAILED                        [ 18%]
tests/test_chunker_semantic.py::test_itemize_document PASSED             [ 19%]
tests/test_chunker_semantic.py::test_semantic_analysis PASSED            [ 20%]
tests/test_chunker_semantic.py::test_extract_and_parse_llm_response_manually PAS
SED [ 21%]
tests/test_chunker_semantic.py::test_add_unit_tags PASSED                [ 22%]
tests/test_chunker_semantic.py::test_create_chunks PASSED                [ 23%]
tests/test_cli.py::test_process_invalid_input_file PASSED                [ 24%]
tests/test_cli.py::test_process_invalid_start_step PASSED                [ 25%]
tests/test_cli.py::test_process_basic PASSED                             [ 25%]
tests/test_cli.py::test_chunk_command PASSED                             [ 26%]
tests/test_cli.py::test_entitize_command PASSED                          [ 27%]
tests/test_cli.py::test_orate_command PASSED                             [ 28%]
tests/test_cli.py::test_tonedown_command PASSED                          [ 29%]
tests/test_cli.py::test_convert_11labs_command PASSED                    [ 30%]
tests/test_cli.py::test_say_command PASSED                               [ 31%]
tests/test_cli.py::test_say_command_with_file PASSED                     [ 32%]
tests/test_cli.py::test_neifix_command PASSED                            [ 33%]
tests/test_cli.py::test_say_command_missing_input PASSED                 [ 34%]
tests/test_cli.py::test_say_command_missing_api_key PASSED               [ 35%]
tests/test_cli.py::test_say_command_env_api_key PASSED                   [ 36%]
tests/test_cli.py::test_debug_logging_configuration PASSED               [ 37%]
tests/test_cli.py::test_verbose_logging_configuration PASSED             [ 37%]
tests/test_cli.py::test_process_pipeline_error PASSED                    [ 38%]
tests/test_cli.py::test_orate_selective_steps PASSED                     [ 39%]
tests/test_cli.py::test_process_with_invalid_output_dir PASSED           [ 40%]
tests/test_cli.py::test_chunk_command_with_invalid_model PASSED          [ 41%]
tests/test_cli.py::test_entitize_command_with_invalid_temperature PASSED [ 42%]
tests/test_cli.py::test_orate_command_no_steps_selected PASSED           [ 43%]
tests/test_cli.py::test_tonedown_command_invalid_min_em_distance PASSED  [ 44%]
tests/test_cli.py::test_convert_11labs_command_with_both_modes PASSED    [ 45%]
tests/test_cli.py::test_say_command_with_both_inputs PASSED              [ 46%]
tests/test_cli.py::test_neifix_command_same_input_output PASSED          [ 47%]
tests/test_cli.py::test_process_with_backup_error PASSED                 [ 48%]
tests/test_cli.py::test_process_with_custom_config PASSED                [ 49%]
tests/test_elevenlabs_converter.py::test_extract_text_from_xml FAILED    [ 50%]
tests/test_elevenlabs_converter.py::test_extract_text_from_xml_with_formatting F
AILED [ 50%]
tests/test_elevenlabs_converter.py::test_process_dialog FAILED           [ 51%]
tests/test_elevenlabs_converter.py::test_process_dialog_with_breaks FAILED [ 52%
]
tests/test_elevenlabs_converter.py::test_process_document_xml FAILED     [ 53%]
tests/test_elevenlabs_converter.py::test_process_document_plaintext FAILED [ 54%
]
tests/test_elevenlabs_converter.py::test_error_handling FAILED           [ 55%]
tests/test_elevenlabs_synthesizer.py::test_sanitize_filename PASSED      [ 56%]
tests/test_elevenlabs_synthesizer.py::test_get_personal_voices PASSED    [ 57%]
tests/test_elevenlabs_synthesizer.py::test_synthesize_with_voice PASSED  [ 58%]
tests/test_elevenlabs_synthesizer.py::test_synthesize_with_all_voices PASSED [ 5
9%]
tests/test_elevenlabs_synthesizer.py::test_synthesize_with_all_voices_missing_ap
i_key PASSED [ 60%]
tests/test_entitizer.py::test_get_chunks PASSED                          [ 61%]
tests/test_entitizer.py::test_get_chunk_text PASSED                      [ 62%]
tests/test_entitizer.py::test_save_current_state PASSED                  [ 62%]
tests/test_entitizer.py::test_extract_item_elements PASSED               [ 63%]
tests/test_entitizer.py::test_merge_tagged_items PASSED                  [ 64%]
tests/test_entitizer.py::test_identify_entities 
-------------------------------- live log call ---------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET https://raw.githubusercontent.c
om/BerriAI/litellm/main/model_prices_and_context_window.json "HTTP/1.1 200 OK"
INFO     LiteLLM:utils.py:2900 
LiteLLM completion() model= gpt-4o; provider = openai
INFO     httpx:_client.py:1025 HTTP Request: POST https://api.openai.com/v1/chat
/completions "HTTP/1.1 200 OK"
INFO     LiteLLM:utils.py:1209 Wrapper: Completed Call, calling success_handler
INFO     LiteLLM:cost_calculator.py:655 selected model name for cost calculation
: openai/gpt-4o-2024-08-06
INFO     LiteLLM:cost_calculator.py:655 selected model name for cost calculation
: openai/gpt-4o-2024-08-06
INFO     LiteLLM:cost_calculator.py:655 selected model name for cost calculation
: openai/gpt-4o-2024-08-06
PASSED                                                                   [ 65%]
tests/test_entitizer.py::test_extract_response_text PASSED               [ 66%]
tests/test_entitizer.py::test_extract_nei_from_tags FAILED               [ 67%]
tests/test_entitizer.py::test_process_chunks 
-------------------------------- live log call ---------------------------------
INFO     LiteLLM:utils.py:2900 
LiteLLM completion() model= gpt-4o; provider = openai
INFO     httpx:_client.py:1025 HTTP Request: POST https://api.openai.com/v1/chat
/completions "HTTP/1.1 200 OK"
INFO     LiteLLM:utils.py:1209 Wrapper: Completed Call, calling success_handler
INFO     LiteLLM:cost_calculator.py:655 selected model name for cost calculation
: openai/gpt-4o-2024-08-06
INFO     LiteLLM:cost_calculator.py:655 selected model name for cost calculation
: openai/gpt-4o-2024-08-06
INFO     LiteLLM:cost_calculator.py:655 selected model name for cost calculation
: openai/gpt-4o-2024-08-06

tests/test_entitizer.py::test_process_document 
-------------------------------- live log call ---------------------------------
INFO     LiteLLM:utils.py:2900 
LiteLLM completion() model= gpt-4o; provider = openai
INFO     httpx:_client.py:1025 HTTP Request: POST https://api.openai.com/v1/chat
/completions "HTTP/1.1 200 OK"
INFO     LiteLLM:utils.py:1209 Wrapper: Completed Call, calling success_handler
INFO     LiteLLM:cost_calculator.py:655 selected model name for cost calculation
: openai/gpt-4o-2024-08-06
INFO     LiteLLM:cost_calculator.py:655 selected model name for cost calculation
: openai/gpt-4o-2024-08-06
INFO     LiteLLM:cost_calculator.py:655 selected model name for cost calculation
: openai/gpt-4o-2024-08-06
PASSED                                                                   [ 69%]
tests/test_entitizer.py::test_error_handling PASSED                      [ 70%]
tests/test_integration.py::test_process_to_chunks PASSED                 [ 71%]
tests/test_integration.py::test_process_chunks PASSED                    [ 72%]
tests/test_integration.py::test_process_to_text PASSED                   [ 73%]
tests/test_integration.py::test_process_to_speech PASSED                 [ 74%]
tests/test_integration.py::test_full_pipeline_integration PASSED         [ 75%]
tests/test_neifix.py::test_transform_nei_content PASSED                  [ 75%]
tests/test_neifix.py::test_transform_nei_content_return_content PASSED   [ 76%]
tests/test_orator.py::test_extract_chunk_items PASSED                    [ 77%]
tests/test_orator.py::test_restructure_sentences PASSED                  [ 78%]
tests/test_orator.py::test_normalize_words PASSED                        [ 79%]
tests/test_orator.py::test_enhance_punctuation FAILED                    [ 80%]
tests/test_orator.py::test_add_emotional_emphasis PASSED                 [ 81%]
tests/test_orator.py::test_merge_processed_items PASSED                  [ 82%]
tests/test_orator.py::test_process_document FAILED                       [ 83%]
tests/test_orator.py::test_error_handling PASSED                         [ 84%]
tests/test_package.py::test_version PASSED                               [ 85%]
tests/test_package.py::test_package_structure PASSED                     [ 86%]
tests/test_pipeline.py::test_pipeline_config_defaults PASSED             [ 87%]
tests/test_pipeline.py::test_pipeline_config_custom PASSED               [ 87%]
tests/test_pipeline.py::test_pipeline_output_directory_creation PASSED   [ 88%]
tests/test_pipeline.py::test_pipeline_progress_tracking PASSED           [ 89%]
tests/test_pipeline.py::test_pipeline_backup_functionality PASSED        [ 90%]
tests/test_pipeline.py::test_pipeline_step_ordering PASSED               [ 91%]
tests/test_pipeline.py::test_pipeline_step_dependencies PASSED           [ 92%]
tests/test_pipeline.py::test_pipeline_resume_from_step PASSED            [ 93%]
tests/test_pipeline.py::test_pipeline_force_restart PASSED               [ 94%]
tests/test_tonedown.py::test_extract_neis_from_document PASSED           [ 95%]
tests/test_tonedown.py::test_detect_language PASSED                      [ 96%]
tests/test_tonedown.py::test_update_nei_tags FAILED                      [ 97%]
tests/test_tonedown.py::test_reduce_emphasis FAILED                      [ 98%]
tests/test_tonedown.py::test_process_document FAILED                     [ 99%]
tests/test_tonedown.py::test_error_handling PASSED                       [100%]

=================================== FAILURES ===================================
__________________________ test_create_item_elements ___________________________

    def test_create_item_elements():
        """Test creation of item elements."""
        items = [
            ("First paragraph", "normal"),
            ("Second paragraph", "following"),
        ]
    
        result = create_item_elements(items)
        assert isinstance(result, list)
        assert len(result) == len(items)
        for item_id, item_xml in result:
            assert isinstance(item_id, str)
            assert isinstance(item_xml, str)
>           assert item_xml.startswith("<item")
E           AssertionError: assert False
E            +  where False = <built-in method startswith of str object at 0x114
28e6f0>('<item')
E            +    where <built-in method startswith of str object at 0x11428e6f0
> = '000000-nscwxw'.startswith

tests/test_chunker.py:179: AssertionError
____________________________ test_process_document _____________________________

temp_workspace = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000
gn/T/pytest-of-adam/pytest-54/test_process_document0/workspace')

    def test_process_document(temp_workspace):
        """Test the complete document processing pipeline."""
        # Create test input file
        input_file = temp_workspace / "input" / "test.md"
        output_file = temp_workspace / "output" / "test.xml"
    
        test_content = """# Test Document
    
    First paragraph with some content.
    
    ## Section 1
    
    Another paragraph here.
    
    * List item 1
    * List item 2
    
    > A blockquote for testing.
    """
    
        input_file.write_text(test_content)
    
        # Process the document
        result = process_document(
            str(input_file),
            str(output_file),
            chunk_size=1000,
            model="gpt-4o",
            temperature=0.2,
            verbose=True,
            backup=True,
        )
    
        assert isinstance(result, dict)
        assert output_file.exists()
    
        # Verify the processed content
        processed_content = output_file.read_text()
        assert "<?xml" in processed_content
>       assert "<document>" in processed_content
E       assert '<document>' in '<?xml version=\'1.0\' encoding=\'utf-8\'?>\n<doc
>\n  <chunk id="0001" tok="239">\n    <unit type="unit" tok="247">\n      <item
xml:space="preserve" tok="236" id="000000-3qqvmi"># Test Document\n\n</item>\n
    <item xml:space="preserve" tok="236" id="3qqvmi-ikzq3g" attach="preceding">F
irst paragraph with some content.\n\n</item>\n      <item xml:space="preserve" t
ok="236" id="ikzq3g-o60v6p">## Section 1\n\n</item>\n      <item xml:space="pres
erve" tok="236" id="o60v6p-l1ewgl" attach="preceding">Another paragraph here.\n\
n</item>\n      <item xml:space="preserve" tok="236" id="l1ewgl-2qcols">* List i
tem 1\n* List item 2\n\n</item>\n      <item xml:space="preserve" tok="236" id="
2qcols-pdwj4z">&gt; A blockquote for testing.\n</item>\n    </unit>\n  </chunk>\
n</doc>\n'

tests/test_chunker.py:256: AssertionError
_____________________________ test_error_handling ______________________________

    def test_error_handling():
        """Test error handling in chunker functions."""
        # Test with empty input
        assert count_tokens("") == 0
        assert escape_xml_chars("") == ""
>       assert generate_hash("") == "000000"
E       AssertionError: assert 'phoiac' == '000000'
E         
E         - 000000
E         + phoiac

tests/test_chunker.py:266: AssertionError
__________________________ test_extract_text_from_xml __________________________

sample_xml = '<?xml version="1.0" encoding="UTF-8"?>\n<document>\n    <metadata>
\n        <title>Test Document</title>\n        <au... with \n            <nei t
ype="person" new="true">New Entity</nei>.\n        </paragraph>\n    </content>\
n</document>'

    def test_extract_text_from_xml(sample_xml):
        """Test extraction of text from XML document."""
        root = etree.fromstring(sample_xml.encode())
        result = extract_text_from_xml(root)
    
        assert isinstance(result, str)
>       assert "This is a test paragraph" in result
E       AssertionError: assert 'This is a test paragraph' in ''

tests/test_elevenlabs_converter.py:22: AssertionError
__________________ test_extract_text_from_xml_with_formatting __________________

    def test_extract_text_from_xml_with_formatting():
        """Test extraction of text with various formatting elements."""
        xml = """<?xml version="1.0" encoding="UTF-8"?>
        <document>
            <content>
                <chunk>
                    <item>
                        This is <em>emphasized</em> text with a
                        <nei>Named Entity</nei> and a
                        <nei new="true">New Entity</nei>.
                        Here's a break: <hr/> and some more text.
                    </item>
                </chunk>
            </content>
        </document>
        """
    
        root = etree.fromstring(xml.encode())
        result = extract_text_from_xml(root)
    
        assert '"emphasized"' in result  # <em> converted to quotes
        assert "Named Entity" in result  # regular NEI preserved
        assert '"New Entity"' in result  # new NEI converted to quotes
>       assert '<break time="0.5s" />' in result  # <hr/> converted to break
E       assert '<break time="0.5s" />' in '\n                    This is "emphas
ized" text with a \n                    Named Entity and a\n
"New Entity".\n                    Here\'s a break:  and some more text.\n
          \n            '

tests/test_elevenlabs_converter.py:52: AssertionError
_____________________________ test_process_dialog ______________________________

    def test_process_dialog():
        """Test dialog processing."""
        text = """Regular text.
    
    ‚Äî Hello, said John.
    ‚Äî Hi there! ‚Äî he continued ‚Äî How are you?
    ‚Äî I'm fine, thanks.
    
    More regular text.
    
    ‚Äî Another dialog starts.
    ‚Äî Yes, it does."""
    
>       result = process_dialog(text)

tests/test_elevenlabs_converter.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

text = "Regular text.\n\n‚Äî Hello, said John.\n‚Äî Hi there! ‚Äî he continued ‚Äî How a
re you?\n‚Äî I'm fine, thanks.\n\nMore regular text.\n\n‚Äî Another dialog starts.\n
‚Äî Yes, it does."

    def process_dialog(text: str) -> str:
        """
        Process dialog in text, converting em dashes to appropriate quotation ma
rks.
    
        Args:
            text: Text with dialog lines
    
        Returns:
            Text with processed dialog
        """
        # Flag indicating whether we're inside dialog
        in_dialog = False
    
        # Process the text line by line
        lines = text.split("\n")
        processed_lines = []
    
        for line in lines:
            if line.strip().startswith("‚Äî "):
                # Line starts with em dash and space - it's a dialog line
                in_dialog = True
                line = "<q>" + line[2:]  # Replace em dash with <q> tag
    
            if in_dialog:
                # Process dialog toggles (‚Äî ) within the line
                parts = line.split(" ‚Äî ")
                if len(parts) > 1:
                    # There are dialog toggles in this line
                    for i in range(len(parts)):
                        if i > 0:
                            # For toggles, close previous and open new
                            parts[i] = "</q><q>" + parts[i]
                    line = " ".join(parts)
    
                # Check if line should end dialog
                if in_dialog and not any(
                    next_line.strip().startswith("‚Äî ")
>                   for next_line in lines[lines.index(line) + 1 : lines.index(l
ine) + 2]
                    if next_line.strip()
                ):
E               ValueError: '<q>Hello, said John.' is not in list

src/e11ocutionist/elevenlabs_converter.py:102: ValueError
_______________________ test_process_dialog_with_breaks ________________________

    def test_process_dialog_with_breaks():
        """Test dialog processing with break tags."""
        text = """‚Äî First line...
    ‚Äî Second line with <break time="1s" /> a pause.
    ‚Äî Third line."""
    
>       result = process_dialog(text)

tests/test_elevenlabs_converter.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

text = '‚Äî First line...\n‚Äî Second line with <break time="1s" /> a pause.\n‚Äî Thir
d line.'

    def process_dialog(text: str) -> str:
        """
        Process dialog in text, converting em dashes to appropriate quotation ma
rks.
    
        Args:
            text: Text with dialog lines
    
        Returns:
            Text with processed dialog
        """
        # Flag indicating whether we're inside dialog
        in_dialog = False
    
        # Process the text line by line
        lines = text.split("\n")
        processed_lines = []
    
        for line in lines:
            if line.strip().startswith("‚Äî "):
                # Line starts with em dash and space - it's a dialog line
                in_dialog = True
                line = "<q>" + line[2:]  # Replace em dash with <q> tag
    
            if in_dialog:
                # Process dialog toggles (‚Äî ) within the line
                parts = line.split(" ‚Äî ")
                if len(parts) > 1:
                    # There are dialog toggles in this line
                    for i in range(len(parts)):
                        if i > 0:
                            # For toggles, close previous and open new
                            parts[i] = "</q><q>" + parts[i]
                    line = " ".join(parts)
    
                # Check if line should end dialog
                if in_dialog and not any(
                    next_line.strip().startswith("‚Äî ")
>                   for next_line in lines[lines.index(line) + 1 : lines.index(l
ine) + 2]
                    if next_line.strip()
                ):
E               ValueError: '<q>First line...' is not in list

src/e11ocutionist/elevenlabs_converter.py:102: ValueError
__________________________ test_process_document_xml ___________________________

temp_workspace = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000
gn/T/pytest-of-adam/pytest-54/test_process_document_xml0/workspace')

    def test_process_document_xml(temp_workspace):
        """Test document processing in XML mode."""
        # Create test input file
        input_file = temp_workspace / "input" / "test.xml"
        output_file = temp_workspace / "output" / "test.txt"
    
        input_content = """<?xml version="1.0" encoding="UTF-8"?>
        <document>
            <content>
                <chunk>
                    <item>Regular paragraph.</item>
                    <item>
                        ‚Äî Hello, said John.
                        ‚Äî Hi there! ‚Äî he continued ‚Äî How are you?
                    </item>
                </chunk>
            </content>
        </document>
        """
    
        input_file.write_text(input_content)
    
        # Process document
>       result = process_document(
            str(input_file),
            str(output_file),
            dialog=True,
            plaintext=False,
            verbose=True,
        )

tests/test_elevenlabs_converter.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/e11ocutionist/elevenlabs_converter.py:178: in process_document
    output_text = process_dialog(output_text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

text = 'Regular paragraph.\n                \n\n\n                    ‚Äî Hello, s
aid John.\n                    ‚Äî Hi there! ‚Äî he continued ‚Äî How are you?\n
          \n            '

    def process_dialog(text: str) -> str:
        """
        Process dialog in text, converting em dashes to appropriate quotation ma
rks.
    
        Args:
            text: Text with dialog lines
    
        Returns:
            Text with processed dialog
        """
        # Flag indicating whether we're inside dialog
        in_dialog = False
    
        # Process the text line by line
        lines = text.split("\n")
        processed_lines = []
    
        for line in lines:
            if line.strip().startswith("‚Äî "):
                # Line starts with em dash and space - it's a dialog line
                in_dialog = True
                line = "<q>" + line[2:]  # Replace em dash with <q> tag
    
            if in_dialog:
                # Process dialog toggles (‚Äî ) within the line
                parts = line.split(" ‚Äî ")
                if len(parts) > 1:
                    # There are dialog toggles in this line
                    for i in range(len(parts)):
                        if i > 0:
                            # For toggles, close previous and open new
                            parts[i] = "</q><q>" + parts[i]
                    line = " ".join(parts)
    
                # Check if line should end dialog
                if in_dialog and not any(
                    next_line.strip().startswith("‚Äî ")
>                   for next_line in lines[lines.index(line) + 1 : lines.index(l
ine) + 2]
                    if next_line.strip()
                ):
E               ValueError: '<q>                  </q><q>Hello, said John.' is n
ot in list

src/e11ocutionist/elevenlabs_converter.py:102: ValueError
_______________________ test_process_document_plaintext ________________________

temp_workspace = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000
gn/T/pytest-of-adam/pytest-54/test_process_document_plaintex0/workspace')

    def test_process_document_plaintext(temp_workspace):
        """Test document processing in plaintext mode."""
        # Create test input file
        input_file = temp_workspace / "input" / "test.txt"
        output_file = temp_workspace / "output" / "test.txt"
    
        input_content = """Regular text.
    
    ‚Äî Hello, said John.
    ‚Äî Hi there! ‚Äî he continued ‚Äî How are you?
    ‚Äî I'm fine, thanks.
    
    More regular text."""
    
        input_file.write_text(input_content)
    
        # Process document
>       result = process_document(
            str(input_file),
            str(output_file),
            dialog=True,
            plaintext=True,
            verbose=True,
        )

tests/test_elevenlabs_converter.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/e11ocutionist/elevenlabs_converter.py:168: in process_document
    output_text = process_dialog(output_text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

text = "Regular text.\n\n‚Äî Hello, said John.\n‚Äî Hi there! ‚Äî he continued ‚Äî How a
re you?\n‚Äî I'm fine, thanks.\n\nMore regular text."

    def process_dialog(text: str) -> str:
        """
        Process dialog in text, converting em dashes to appropriate quotation ma
rks.
    
        Args:
            text: Text with dialog lines
    
        Returns:
            Text with processed dialog
        """
        # Flag indicating whether we're inside dialog
        in_dialog = False
    
        # Process the text line by line
        lines = text.split("\n")
        processed_lines = []
    
        for line in lines:
            if line.strip().startswith("‚Äî "):
                # Line starts with em dash and space - it's a dialog line
                in_dialog = True
                line = "<q>" + line[2:]  # Replace em dash with <q> tag
    
            if in_dialog:
                # Process dialog toggles (‚Äî ) within the line
                parts = line.split(" ‚Äî ")
                if len(parts) > 1:
                    # There are dialog toggles in this line
                    for i in range(len(parts)):
                        if i > 0:
                            # For toggles, close previous and open new
                            parts[i] = "</q><q>" + parts[i]
                    line = " ".join(parts)
    
                # Check if line should end dialog
                if in_dialog and not any(
                    next_line.strip().startswith("‚Äî ")
>                   for next_line in lines[lines.index(line) + 1 : lines.index(l
ine) + 2]
                    if next_line.strip()
                ):
E               ValueError: '<q>Hello, said John.' is not in list

src/e11ocutionist/elevenlabs_converter.py:102: ValueError
_____________________________ test_error_handling ______________________________

temp_workspace = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000
gn/T/pytest-of-adam/pytest-54/test_error_handling0/workspace')

    def test_error_handling(temp_workspace):
        """Test error handling in document processing."""
        # Test with invalid XML
        input_file = temp_workspace / "input" / "invalid.xml"
        output_file = temp_workspace / "output" / "invalid.txt"
    
        input_file.write_text("<invalid>")
    
        result = process_document(
            str(input_file),
            str(output_file),
            dialog=True,
            plaintext=False,
            verbose=True,
        )
    
        assert isinstance(result, dict)
>       assert result["success"] is False
E       assert True is False

tests/test_elevenlabs_converter.py:194: AssertionError
__________________________ test_extract_nei_from_tags __________________________

    def test_extract_nei_from_tags():
        """Test extraction of NEIs from tagged text."""
        tagged_text = """
        <item>
            <nei type="person">John Smith</nei> visited
            <nei type="location">New York</nei>.
        </item>
        """
    
        result = extract_nei_from_tags(tagged_text)
        assert isinstance(result, dict)
>       assert "John Smith" in result
E       AssertionError: assert 'John Smith' in {'john smith': {'count': 1, 'new'
: True, 'orig': '', 'text': 'John Smith'}, 'new york': {'count': 1, 'new': True,
 'orig': '', 'text': 'New York'}}

tests/test_entitizer.py:181: AssertionError
___________________________ test_enhance_punctuation ___________________________

    def test_enhance_punctuation():
        """Test punctuation enhancement."""
        items = [
            ("id1", "This needs a period"),
            ("id2", "Is this a question"),
            ("id3", "Add some emphasis here"),
        ]
    
        result = enhance_punctuation(items)
        assert isinstance(result, list)
        assert len(result) == len(items)
        for item_id, content in result:
            assert isinstance(item_id, str)
            assert isinstance(content, str)
            assert content.strip()
>           assert content[-1] in ".!?"  # Should end with punctuation
E           AssertionError: assert 'd' in '.!?'

tests/test_orator.py:83: AssertionError
____________________________ test_process_document _____________________________

temp_workspace = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000
gn/T/pytest-of-adam/pytest-54/test_process_document2/workspace')

    def test_process_document(temp_workspace):
        """Test the complete document processing pipeline."""
        # Create test input file
        input_file = temp_workspace / "input" / "test.xml"
        output_file = temp_workspace / "output" / "test.xml"
    
        test_content = """<?xml version="1.0" encoding="UTF-8"?>
    <document>
        <content>
            <item id="id1">This needs processing.</item>
            <item id="id2">This also needs work.</item>
        </content>
    </document>"""
    
        input_file.write_text(test_content)
    
        # Process the document
        result = process_document(
            str(input_file),
            str(output_file),
            steps=["restructure", "normalize", "punctuate", "emphasize"],
            model="gpt-4o",
            temperature=0.2,
            verbose=True,
            backup=True,
        )
    
        assert isinstance(result, dict)
>       assert "processed_items" in result
E       AssertionError: assert 'processed_items' in {'input_file': '/private/var
/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-54/test_proce
ss_document2/workspace/input/test.xml', 'items_processed': 2, 'output_file': '/p
rivate/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-54/
test_process_document2/workspace/output/test.xml', 'steps_performed': [], ...}

tests/test_orator.py:158: AssertionError
_____________________________ test_update_nei_tags _____________________________

    def test_update_nei_tags():
        """Test updating NEI tags in XML."""
        xml_content = """<?xml version="1.0" encoding="UTF-8"?>
    <document>
        <content>
            <p><nei type="person">John Smith</nei> is here.</p>
        </content>
    </document>"""
    
        nei_dict = {
            "john smith": {
                "text": "John Smith",
                "new": True,
                "orig": "Jon Smyth",
                "count": 1,
            }
        }
    
        result = update_nei_tags(xml_content, nei_dict)
        assert isinstance(result, str)
    
        # Parse and verify the updated XML
        root = etree.fromstring(result.encode())
        nei = root.find(".//nei")
        assert nei is not None
>       assert nei.get("new") == "true"
E       AssertionError: assert None == 'true'
E        +  where None = get('new')
E        +    where get = <Element nei at 0x120a46500>.get

tests/test_tonedown.py:79: AssertionError
_____________________________ test_reduce_emphasis _____________________________

    def test_reduce_emphasis():
        """Test emphasis reduction in XML."""
        xml_content = """<?xml version="1.0" encoding="UTF-8"?>
    <document>
        <content>
            <p>This is <em>very</em> important and this is also <em>very</em>
            important.</p>
        </content>
    </document>"""
    
        # Test with default minimum distance
        result = reduce_emphasis(xml_content)
        assert isinstance(result, str)
    
        # Parse and count remaining emphasis tags
        root = etree.fromstring(result.encode())
        em_tags = root.findall(".//em")
        assert len(em_tags) < 2  # At least one emphasis should be removed
    
        # Test with large minimum distance (should preserve all emphasis)
        result = reduce_emphasis(xml_content, min_distance=1000)
        root = etree.fromstring(result.encode())
        em_tags = root.findall(".//em")
>       assert len(em_tags) == 2
E       assert 1 == 2
E        +  where 1 = len([<Element em at 0x120abb1c0>])

tests/test_tonedown.py:106: AssertionError
____________________________ test_process_document _____________________________

temp_workspace = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000
gn/T/pytest-of-adam/pytest-54/test_process_document3/workspace')

    def test_process_document(temp_workspace):
        """Test the complete document processing pipeline."""
        # Create test input file
        input_file = temp_workspace / "input" / "test.xml"
        output_file = temp_workspace / "output" / "test.xml"
    
        test_content = """<?xml version="1.0" encoding="UTF-8"?>
    <document>
        <content>
            <p><nei type="person">John Smith</nei> said this is <em>very</em>
            important.</p>
            <p>And this is also <em>very</em> important, said
            <nei type="person">John Smith</nei>.</p>
        </content>
    </document>"""
    
        input_file.write_text(test_content)
    
        # Process the document
        result = process_document(
            str(input_file),
            str(output_file),
            model="gpt-4o",
            temperature=0.2,
            min_em_distance=5,
            backup=True,
            verbose=True,
        )
    
        assert isinstance(result, str)
>       assert output_file.exists()
E       AssertionError: assert False
E        +  where False = exists()
E        +    where exists = PosixPath('/private/var/folders/05/clcynl0509ldxltl
599hhhx40000gn/T/pytest-of-adam/pytest-54/test_process_document3/workspace/outpu
t/test.xml').exists

tests/test_tonedown.py:139: AssertionError
============================= slowest 10 durations =============================
6.12s call     tests/test_entitizer.py::test_process_document
5.72s call     tests/test_entitizer.py::test_identify_entities
3.01s call     tests/test_entitizer.py::test_process_chunks
0.49s call     tests/test_chunker.py::test_count_tokens
0.01s call     tests/test_cli.py::test_say_command_env_api_key
0.01s call     tests/test_cli.py::test_entitize_command
0.01s call     tests/test_cli.py::test_process_pipeline_error
0.01s call     tests/test_cli.py::test_process_with_backup_error
0.01s call     tests/test_cli.py::test_process_with_custom_config
0.01s call     tests/test_cli.py::test_chunk_command
=========================== short test summary info ============================
FAILED tests/test_chunker.py::test_create_item_elements - AssertionError: assert
 False
FAILED tests/test_chunker.py::test_process_document - assert '<document>' in '<?
xml version=\'1.0\' encoding=\'utf-8\'?>\n<doc>\n...
FAILED tests/test_chunker.py::test_error_handling - AssertionError: assert 'phoi
ac' == '000000'
FAILED tests/test_elevenlabs_converter.py::test_extract_text_from_xml - Assertio
nError: assert 'This is a test paragraph' in ''
FAILED tests/test_elevenlabs_converter.py::test_extract_text_from_xml_with_forma
tting - assert '<break time="0.5s" />' in '\n                    This is "emphas
ize...
FAILED tests/test_elevenlabs_converter.py::test_process_dialog - ValueError: '<q
>Hello, said John.' is not in list
FAILED tests/test_elevenlabs_converter.py::test_process_dialog_with_breaks - Val
ueError: '<q>First line...' is not in list
FAILED tests/test_elevenlabs_converter.py::test_process_document_xml - ValueErro
r: '<q>                  </q><q>Hello, said John.' is not in list
FAILED tests/test_elevenlabs_converter.py::test_process_document_plaintext - Val
ueError: '<q>Hello, said John.' is not in list
FAILED tests/test_elevenlabs_converter.py::test_error_handling - assert True is 
False
FAILED tests/test_entitizer.py::test_extract_nei_from_tags - AssertionError: ass
ert 'John Smith' in {'john smith': {'count': 1, 'new': T...
FAILED tests/test_orator.py::test_enhance_punctuation - AssertionError: assert '
d' in '.!?'
FAILED tests/test_orator.py::test_process_document - AssertionError: assert 'pro
cessed_items' in {'input_file': '/private/var/fo...
FAILED tests/test_tonedown.py::test_update_nei_tags - AssertionError: assert Non
e == 'true'
FAILED tests/test_tonedown.py::test_reduce_emphasis - assert 1 == 2
FAILED tests/test_tonedown.py::test_process_document - AssertionError: assert Fa
lse
======================== 16 failed, 92 passed in 18.48s ========================

```

---

I'll help analyze and improve the test suite for the e11ocutionist project. Let me first gather more information about the current state of the tests and codebase.

Let me first check the test directory structure:

---

<details>
            <summary>Listed directory tests ‚Ä¢ **16** results</summary>
        
| Name |
|-------|
| üìÅ `__pycache__` |
| üìÑ `.DS_Store` |
| üìÑ `test_elevenlabs_converter.py` |
| üìÑ `test_entitizer.py` |
| üìÑ `conftest.py` |
| üìÑ `test_chunker.py` |
| üìÑ `test_orator.py` |
| üìÅ `fixtures` |
| üìÑ `test_tonedown.py` |
| üìÑ `test_cli.py` |
| üìÑ `test_elevenlabs_synthesizer.py` |
| üìÑ `test_pipeline.py` |
| üìÑ `test_chunker_semantic.py` |
| üìÑ `test_integration.py` |
| üìÑ `test_neifix.py` |
| üìÑ `test_package.py` |

</details>

---





---

_**User**_

continue

---

_**Assistant**_

Let me analyze the test files and identify areas for improvement.

---

